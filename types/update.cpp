// This file generated by libqtelegram-code-generator.
// You can download it from: https://github.com/Aseman-Land/libqtelegram-code-generator
// DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN

#include "update.h"
#include "core/inboundpkt.h"
#include "core/outboundpkt.h"

using namespace Tg;

Types::Update::Update(UpdateType classType, InboundPkt *in) :
    m_authKeyId(0),
    m_blocked(false),
    m_chatId(0),
    m_date(0),
    m_id(0),
    m_inviterId(0),
    m_maxDate(0),
    m_maxId(0),
    m_popup(false),
    m_previous(false),
    m_pts(0),
    m_ptsCount(0),
    m_qts(0),
    m_randomId(0),
    m_userId(0),
    m_version(0),
    m_classType(classType)
{
    if(in) fetch(in);
}

Types::Update::Update(InboundPkt *in) :
    m_authKeyId(0),
    m_blocked(false),
    m_chatId(0),
    m_date(0),
    m_id(0),
    m_inviterId(0),
    m_maxDate(0),
    m_maxId(0),
    m_popup(false),
    m_previous(false),
    m_pts(0),
    m_ptsCount(0),
    m_qts(0),
    m_randomId(0),
    m_userId(0),
    m_version(0),
    m_classType(typeUpdateNewMessage)
{
    fetch(in);
}

void Types::Update::setAction(const SendMessageAction &action) {
    m_action = action;
}

SendMessageAction Types::Update::action() const {
    return m_action;
}

void Types::Update::setAuthKeyId(qint64 authKeyId) {
    m_authKeyId = authKeyId;
}

qint64 Types::Update::authKeyId() const {
    return m_authKeyId;
}

void Types::Update::setBlocked(bool blocked) {
    m_blocked = blocked;
}

bool Types::Update::blocked() const {
    return m_blocked;
}

void Types::Update::setChat(const EncryptedChat &chat) {
    m_chat = chat;
}

EncryptedChat Types::Update::chat() const {
    return m_chat;
}

void Types::Update::setChatId(qint32 chatId) {
    m_chatId = chatId;
}

qint32 Types::Update::chatId() const {
    return m_chatId;
}

void Types::Update::setDate(qint32 date) {
    m_date = date;
}

qint32 Types::Update::date() const {
    return m_date;
}

void Types::Update::setDcOptions(const QList<DcOption> &dcOptions) {
    m_dcOptions = dcOptions;
}

QList<DcOption> Types::Update::dcOptions() const {
    return m_dcOptions;
}

void Types::Update::setDevice(const QString &device) {
    m_device = device;
}

QString Types::Update::device() const {
    return m_device;
}

void Types::Update::setFirstName(const QString &firstName) {
    m_firstName = firstName;
}

QString Types::Update::firstName() const {
    return m_firstName;
}

void Types::Update::setForeignLink(const ContactLink &foreignLink) {
    m_foreignLink = foreignLink;
}

ContactLink Types::Update::foreignLink() const {
    return m_foreignLink;
}

void Types::Update::setId(qint32 id) {
    m_id = id;
}

qint32 Types::Update::id() const {
    return m_id;
}

void Types::Update::setInviterId(qint32 inviterId) {
    m_inviterId = inviterId;
}

qint32 Types::Update::inviterId() const {
    return m_inviterId;
}

void Types::Update::setKey(const PrivacyKey &key) {
    m_key = key;
}

PrivacyKey Types::Update::key() const {
    return m_key;
}

void Types::Update::setLastName(const QString &lastName) {
    m_lastName = lastName;
}

QString Types::Update::lastName() const {
    return m_lastName;
}

void Types::Update::setLocation(const QString &location) {
    m_location = location;
}

QString Types::Update::location() const {
    return m_location;
}

void Types::Update::setMaxDate(qint32 maxDate) {
    m_maxDate = maxDate;
}

qint32 Types::Update::maxDate() const {
    return m_maxDate;
}

void Types::Update::setMaxId(qint32 maxId) {
    m_maxId = maxId;
}

qint32 Types::Update::maxId() const {
    return m_maxId;
}

void Types::Update::setMedia(const MessageMedia &media) {
    m_media = media;
}

MessageMedia Types::Update::media() const {
    return m_media;
}

void Types::Update::setMessageEncrypted(const EncryptedMessage &messageEncrypted) {
    m_messageEncrypted = messageEncrypted;
}

EncryptedMessage Types::Update::messageEncrypted() const {
    return m_messageEncrypted;
}

void Types::Update::setMessageGeoChat(const GeoChatMessage &messageGeoChat) {
    m_messageGeoChat = messageGeoChat;
}

GeoChatMessage Types::Update::messageGeoChat() const {
    return m_messageGeoChat;
}

void Types::Update::setMessage(const Message &message) {
    m_message = message;
}

Message Types::Update::message() const {
    return m_message;
}

void Types::Update::setMessageString(const QString &messageString) {
    m_messageString = messageString;
}

QString Types::Update::messageString() const {
    return m_messageString;
}

void Types::Update::setMessages(const QList<qint32> &messages) {
    m_messages = messages;
}

QList<qint32> Types::Update::messages() const {
    return m_messages;
}

void Types::Update::setMyLink(const ContactLink &myLink) {
    m_myLink = myLink;
}

ContactLink Types::Update::myLink() const {
    return m_myLink;
}

void Types::Update::setNotifySettings(const PeerNotifySettings &notifySettings) {
    m_notifySettings = notifySettings;
}

PeerNotifySettings Types::Update::notifySettings() const {
    return m_notifySettings;
}

void Types::Update::setParticipants(const ChatParticipants &participants) {
    m_participants = participants;
}

ChatParticipants Types::Update::participants() const {
    return m_participants;
}

void Types::Update::setPeerNotify(const NotifyPeer &peerNotify) {
    m_peerNotify = peerNotify;
}

NotifyPeer Types::Update::peerNotify() const {
    return m_peerNotify;
}

void Types::Update::setPeer(const Peer &peer) {
    m_peer = peer;
}

Peer Types::Update::peer() const {
    return m_peer;
}

void Types::Update::setPhone(const QString &phone) {
    m_phone = phone;
}

QString Types::Update::phone() const {
    return m_phone;
}

void Types::Update::setPhoto(const UserProfilePhoto &photo) {
    m_photo = photo;
}

UserProfilePhoto Types::Update::photo() const {
    return m_photo;
}

void Types::Update::setPopup(bool popup) {
    m_popup = popup;
}

bool Types::Update::popup() const {
    return m_popup;
}

void Types::Update::setPrevious(bool previous) {
    m_previous = previous;
}

bool Types::Update::previous() const {
    return m_previous;
}

void Types::Update::setPts(qint32 pts) {
    m_pts = pts;
}

qint32 Types::Update::pts() const {
    return m_pts;
}

void Types::Update::setPtsCount(qint32 ptsCount) {
    m_ptsCount = ptsCount;
}

qint32 Types::Update::ptsCount() const {
    return m_ptsCount;
}

void Types::Update::setQts(qint32 qts) {
    m_qts = qts;
}

qint32 Types::Update::qts() const {
    return m_qts;
}

void Types::Update::setRandomId(qint64 randomId) {
    m_randomId = randomId;
}

qint64 Types::Update::randomId() const {
    return m_randomId;
}

void Types::Update::setRules(const QList<PrivacyRule> &rules) {
    m_rules = rules;
}

QList<PrivacyRule> Types::Update::rules() const {
    return m_rules;
}

void Types::Update::setStatus(const UserStatus &status) {
    m_status = status;
}

UserStatus Types::Update::status() const {
    return m_status;
}

void Types::Update::setType(const QString &type) {
    m_type = type;
}

QString Types::Update::type() const {
    return m_type;
}

void Types::Update::setUserId(qint32 userId) {
    m_userId = userId;
}

qint32 Types::Update::userId() const {
    return m_userId;
}

void Types::Update::setUsername(const QString &username) {
    m_username = username;
}

QString Types::Update::username() const {
    return m_username;
}

void Types::Update::setVersion(qint32 version) {
    m_version = version;
}

qint32 Types::Update::version() const {
    return m_version;
}

void Types::Update::setWebpage(const WebPage &webpage) {
    m_webpage = webpage;
}

WebPage Types::Update::webpage() const {
    return m_webpage;
}

bool Update::operator ==(const Update &b) {
    return m_action == b.m_action &&
           m_authKeyId == b.m_authKeyId &&
           m_blocked == b.m_blocked &&
           m_chat == b.m_chat &&
           m_chatId == b.m_chatId &&
           m_date == b.m_date &&
           m_dcOptions == b.m_dcOptions &&
           m_device == b.m_device &&
           m_firstName == b.m_firstName &&
           m_foreignLink == b.m_foreignLink &&
           m_id == b.m_id &&
           m_inviterId == b.m_inviterId &&
           m_key == b.m_key &&
           m_lastName == b.m_lastName &&
           m_location == b.m_location &&
           m_maxDate == b.m_maxDate &&
           m_maxId == b.m_maxId &&
           m_media == b.m_media &&
           m_messageEncrypted == b.m_messageEncrypted &&
           m_messageGeoChat == b.m_messageGeoChat &&
           m_message == b.m_message &&
           m_messageString == b.m_messageString &&
           m_messages == b.m_messages &&
           m_myLink == b.m_myLink &&
           m_notifySettings == b.m_notifySettings &&
           m_participants == b.m_participants &&
           m_peerNotify == b.m_peerNotify &&
           m_peer == b.m_peer &&
           m_phone == b.m_phone &&
           m_photo == b.m_photo &&
           m_popup == b.m_popup &&
           m_previous == b.m_previous &&
           m_pts == b.m_pts &&
           m_ptsCount == b.m_ptsCount &&
           m_qts == b.m_qts &&
           m_randomId == b.m_randomId &&
           m_rules == b.m_rules &&
           m_status == b.m_status &&
           m_type == b.m_type &&
           m_userId == b.m_userId &&
           m_username == b.m_username &&
           m_version == b.m_version &&
           m_webpage == b.m_webpage;
}

void Update::setClassType(Update::UpdateType classType) {
    m_classType = classType;
}

Types::Update::UpdateType Update::classType() const {
    return m_classType;
}

bool Types::Update::fetch(InboundPkt *in) {
    LQTG_FETCH_LOG;
    int x = in->fetchInt();
    switch(x) {
    case typeUpdateNewMessage: {
        m_message.fetch(in);
        m_pts = in->fetchInt();
        m_ptsCount = in->fetchInt();
        m_classType = static_cast<UpdateType>(x);
        return true;
    }
        break;
    
    case typeUpdateMessageID: {
        m_id = in->fetchInt();
        m_randomId = in->fetchLong();
        m_classType = static_cast<UpdateType>(x);
        return true;
    }
        break;
    
    case typeUpdateDeleteMessages: {
        if(in->fetchInt() != (qint32)TL_Vector) return false;
        qint32 m_messages_length = in->fetchInt();
        m_messages.clear();
        for (qint32 i = 0; i < m_messages_length; i++) {
            qint32 type;
            type = in->fetchInt();
            m_messages.append(type);
        }
        m_pts = in->fetchInt();
        m_ptsCount = in->fetchInt();
        m_classType = static_cast<UpdateType>(x);
        return true;
    }
        break;
    
    case typeUpdateUserTyping: {
        m_userId = in->fetchInt();
        m_action.fetch(in);
        m_classType = static_cast<UpdateType>(x);
        return true;
    }
        break;
    
    case typeUpdateChatUserTyping: {
        m_chatId = in->fetchInt();
        m_userId = in->fetchInt();
        m_action.fetch(in);
        m_classType = static_cast<UpdateType>(x);
        return true;
    }
        break;
    
    case typeUpdateChatParticipants: {
        m_participants.fetch(in);
        m_classType = static_cast<UpdateType>(x);
        return true;
    }
        break;
    
    case typeUpdateUserStatus: {
        m_userId = in->fetchInt();
        m_status.fetch(in);
        m_classType = static_cast<UpdateType>(x);
        return true;
    }
        break;
    
    case typeUpdateUserName: {
        m_userId = in->fetchInt();
        m_firstName = in->fetchQString();
        m_lastName = in->fetchQString();
        m_username = in->fetchQString();
        m_classType = static_cast<UpdateType>(x);
        return true;
    }
        break;
    
    case typeUpdateUserPhoto: {
        m_userId = in->fetchInt();
        m_date = in->fetchInt();
        m_photo.fetch(in);
        m_previous = in->fetchBool();
        m_classType = static_cast<UpdateType>(x);
        return true;
    }
        break;
    
    case typeUpdateContactRegistered: {
        m_userId = in->fetchInt();
        m_date = in->fetchInt();
        m_classType = static_cast<UpdateType>(x);
        return true;
    }
        break;
    
    case typeUpdateContactLink: {
        m_userId = in->fetchInt();
        m_myLink.fetch(in);
        m_foreignLink.fetch(in);
        m_classType = static_cast<UpdateType>(x);
        return true;
    }
        break;
    
    case typeUpdateNewAuthorization: {
        m_authKeyId = in->fetchLong();
        m_date = in->fetchInt();
        m_device = in->fetchQString();
        m_location = in->fetchQString();
        m_classType = static_cast<UpdateType>(x);
        return true;
    }
        break;
    
    case typeUpdateNewGeoChatMessage: {
        m_messageGeoChat.fetch(in);
        m_classType = static_cast<UpdateType>(x);
        return true;
    }
        break;
    
    case typeUpdateNewEncryptedMessage: {
        m_messageEncrypted.fetch(in);
        m_qts = in->fetchInt();
        m_classType = static_cast<UpdateType>(x);
        return true;
    }
        break;
    
    case typeUpdateEncryptedChatTyping: {
        m_chatId = in->fetchInt();
        m_classType = static_cast<UpdateType>(x);
        return true;
    }
        break;
    
    case typeUpdateEncryption: {
        m_chat.fetch(in);
        m_date = in->fetchInt();
        m_classType = static_cast<UpdateType>(x);
        return true;
    }
        break;
    
    case typeUpdateEncryptedMessagesRead: {
        m_chatId = in->fetchInt();
        m_maxDate = in->fetchInt();
        m_date = in->fetchInt();
        m_classType = static_cast<UpdateType>(x);
        return true;
    }
        break;
    
    case typeUpdateChatParticipantAdd: {
        m_chatId = in->fetchInt();
        m_userId = in->fetchInt();
        m_inviterId = in->fetchInt();
        m_version = in->fetchInt();
        m_classType = static_cast<UpdateType>(x);
        return true;
    }
        break;
    
    case typeUpdateChatParticipantDelete: {
        m_chatId = in->fetchInt();
        m_userId = in->fetchInt();
        m_version = in->fetchInt();
        m_classType = static_cast<UpdateType>(x);
        return true;
    }
        break;
    
    case typeUpdateDcOptions: {
        if(in->fetchInt() != (qint32)TL_Vector) return false;
        qint32 m_dcOptions_length = in->fetchInt();
        m_dcOptions.clear();
        for (qint32 i = 0; i < m_dcOptions_length; i++) {
            DcOption type;
            type.fetch(in);
            m_dcOptions.append(type);
        }
        m_classType = static_cast<UpdateType>(x);
        return true;
    }
        break;
    
    case typeUpdateUserBlocked: {
        m_userId = in->fetchInt();
        m_blocked = in->fetchBool();
        m_classType = static_cast<UpdateType>(x);
        return true;
    }
        break;
    
    case typeUpdateNotifySettings: {
        m_peerNotify.fetch(in);
        m_notifySettings.fetch(in);
        m_classType = static_cast<UpdateType>(x);
        return true;
    }
        break;
    
    case typeUpdateServiceNotification: {
        m_type = in->fetchQString();
        m_messageString = in->fetchQString();
        m_media.fetch(in);
        m_popup = in->fetchBool();
        m_classType = static_cast<UpdateType>(x);
        return true;
    }
        break;
    
    case typeUpdatePrivacy: {
        m_key.fetch(in);
        if(in->fetchInt() != (qint32)TL_Vector) return false;
        qint32 m_rules_length = in->fetchInt();
        m_rules.clear();
        for (qint32 i = 0; i < m_rules_length; i++) {
            PrivacyRule type;
            type.fetch(in);
            m_rules.append(type);
        }
        m_classType = static_cast<UpdateType>(x);
        return true;
    }
        break;
    
    case typeUpdateUserPhone: {
        m_userId = in->fetchInt();
        m_phone = in->fetchQString();
        m_classType = static_cast<UpdateType>(x);
        return true;
    }
        break;
    
    case typeUpdateReadHistoryInbox: {
        m_peer.fetch(in);
        m_maxId = in->fetchInt();
        m_pts = in->fetchInt();
        m_ptsCount = in->fetchInt();
        m_classType = static_cast<UpdateType>(x);
        return true;
    }
        break;
    
    case typeUpdateReadHistoryOutbox: {
        m_peer.fetch(in);
        m_maxId = in->fetchInt();
        m_pts = in->fetchInt();
        m_ptsCount = in->fetchInt();
        m_classType = static_cast<UpdateType>(x);
        return true;
    }
        break;
    
    case typeUpdateWebPage: {
        m_webpage.fetch(in);
        m_classType = static_cast<UpdateType>(x);
        return true;
    }
        break;
    
    case typeUpdateReadMessagesContents: {
        if(in->fetchInt() != (qint32)TL_Vector) return false;
        qint32 m_messages_length = in->fetchInt();
        m_messages.clear();
        for (qint32 i = 0; i < m_messages_length; i++) {
            qint32 type;
            type = in->fetchInt();
            m_messages.append(type);
        }
        m_pts = in->fetchInt();
        m_ptsCount = in->fetchInt();
        m_classType = static_cast<UpdateType>(x);
        return true;
    }
        break;
    
    default:
        LQTG_FETCH_ASSERT;
        return false;
    }
}

bool Types::Update::push(OutboundPkt *out) const {
    out->appendInt(m_classType);
    switch(m_classType) {
    case typeUpdateNewMessage: {
        m_message.push(out);
        out->appendInt(m_pts);
        out->appendInt(m_ptsCount);
        return true;
    }
        break;
    
    case typeUpdateMessageID: {
        out->appendInt(m_id);
        out->appendLong(m_randomId);
        return true;
    }
        break;
    
    case typeUpdateDeleteMessages: {
        out->appendInt(TL_Vector);
        out->appendInt(m_messages.count());
        for (qint32 i = 0; i < m_messages.count(); i++) {
            out->appendInt(m_messages[i]);
        }
        out->appendInt(m_pts);
        out->appendInt(m_ptsCount);
        return true;
    }
        break;
    
    case typeUpdateUserTyping: {
        out->appendInt(m_userId);
        m_action.push(out);
        return true;
    }
        break;
    
    case typeUpdateChatUserTyping: {
        out->appendInt(m_chatId);
        out->appendInt(m_userId);
        m_action.push(out);
        return true;
    }
        break;
    
    case typeUpdateChatParticipants: {
        m_participants.push(out);
        return true;
    }
        break;
    
    case typeUpdateUserStatus: {
        out->appendInt(m_userId);
        m_status.push(out);
        return true;
    }
        break;
    
    case typeUpdateUserName: {
        out->appendInt(m_userId);
        out->appendQString(m_firstName);
        out->appendQString(m_lastName);
        out->appendQString(m_username);
        return true;
    }
        break;
    
    case typeUpdateUserPhoto: {
        out->appendInt(m_userId);
        out->appendInt(m_date);
        m_photo.push(out);
        out->appendBool(m_previous);
        return true;
    }
        break;
    
    case typeUpdateContactRegistered: {
        out->appendInt(m_userId);
        out->appendInt(m_date);
        return true;
    }
        break;
    
    case typeUpdateContactLink: {
        out->appendInt(m_userId);
        m_myLink.push(out);
        m_foreignLink.push(out);
        return true;
    }
        break;
    
    case typeUpdateNewAuthorization: {
        out->appendLong(m_authKeyId);
        out->appendInt(m_date);
        out->appendQString(m_device);
        out->appendQString(m_location);
        return true;
    }
        break;
    
    case typeUpdateNewGeoChatMessage: {
        m_messageGeoChat.push(out);
        return true;
    }
        break;
    
    case typeUpdateNewEncryptedMessage: {
        m_messageEncrypted.push(out);
        out->appendInt(m_qts);
        return true;
    }
        break;
    
    case typeUpdateEncryptedChatTyping: {
        out->appendInt(m_chatId);
        return true;
    }
        break;
    
    case typeUpdateEncryption: {
        m_chat.push(out);
        out->appendInt(m_date);
        return true;
    }
        break;
    
    case typeUpdateEncryptedMessagesRead: {
        out->appendInt(m_chatId);
        out->appendInt(m_maxDate);
        out->appendInt(m_date);
        return true;
    }
        break;
    
    case typeUpdateChatParticipantAdd: {
        out->appendInt(m_chatId);
        out->appendInt(m_userId);
        out->appendInt(m_inviterId);
        out->appendInt(m_version);
        return true;
    }
        break;
    
    case typeUpdateChatParticipantDelete: {
        out->appendInt(m_chatId);
        out->appendInt(m_userId);
        out->appendInt(m_version);
        return true;
    }
        break;
    
    case typeUpdateDcOptions: {
        out->appendInt(TL_Vector);
        out->appendInt(m_dcOptions.count());
        for (qint32 i = 0; i < m_dcOptions.count(); i++) {
            m_dcOptions[i].push(out);
        }
        return true;
    }
        break;
    
    case typeUpdateUserBlocked: {
        out->appendInt(m_userId);
        out->appendBool(m_blocked);
        return true;
    }
        break;
    
    case typeUpdateNotifySettings: {
        m_peerNotify.push(out);
        m_notifySettings.push(out);
        return true;
    }
        break;
    
    case typeUpdateServiceNotification: {
        out->appendQString(m_type);
        out->appendQString(m_messageString);
        m_media.push(out);
        out->appendBool(m_popup);
        return true;
    }
        break;
    
    case typeUpdatePrivacy: {
        m_key.push(out);
        out->appendInt(TL_Vector);
        out->appendInt(m_rules.count());
        for (qint32 i = 0; i < m_rules.count(); i++) {
            m_rules[i].push(out);
        }
        return true;
    }
        break;
    
    case typeUpdateUserPhone: {
        out->appendInt(m_userId);
        out->appendQString(m_phone);
        return true;
    }
        break;
    
    case typeUpdateReadHistoryInbox: {
        m_peer.push(out);
        out->appendInt(m_maxId);
        out->appendInt(m_pts);
        out->appendInt(m_ptsCount);
        return true;
    }
        break;
    
    case typeUpdateReadHistoryOutbox: {
        m_peer.push(out);
        out->appendInt(m_maxId);
        out->appendInt(m_pts);
        out->appendInt(m_ptsCount);
        return true;
    }
        break;
    
    case typeUpdateWebPage: {
        m_webpage.push(out);
        return true;
    }
        break;
    
    case typeUpdateReadMessagesContents: {
        out->appendInt(TL_Vector);
        out->appendInt(m_messages.count());
        for (qint32 i = 0; i < m_messages.count(); i++) {
            out->appendInt(m_messages[i]);
        }
        out->appendInt(m_pts);
        out->appendInt(m_ptsCount);
        return true;
    }
        break;
    
    default:
        return false;
    }
}

