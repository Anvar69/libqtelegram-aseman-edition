// This file generated by libqtelegram-code-generator.
// You can download it from: https://github.com/Aseman-Land/libqtelegram-code-generator
// DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN

#include "photosize.h"

using namespace Tg;
using namespace Types;

Types::PhotoSize::PhotoSize(PhotoSizeType classType, InboundPkt *in) :
    m_h(0),
    m_size(0),
    m_w(0),
    m_classType(classType)
{
    if(in) fetch(in);
}

Types::PhotoSize::PhotoSize(InboundPkt *in) :
    m_h(0),
    m_size(0),
    m_w(0),
    m_classType(typePhotoSizeEmpty)
{
    fetch(in);
}

void Types::PhotoSize::setBytes(const QByteArray &bytes) {
    m_bytes = bytes;
}

QByteArray Types::PhotoSize::bytes() const {
    return m_bytes;
}

void Types::PhotoSize::setH(qint32 h) {
    m_h = h;
}

qint32 Types::PhotoSize::h() const {
    return m_h;
}

void Types::PhotoSize::setLocation(const FileLocation &location) {
    m_location = location;
}

FileLocation Types::PhotoSize::location() const {
    return m_location;
}

void Types::PhotoSize::setSize(qint32 size) {
    m_size = size;
}

qint32 Types::PhotoSize::size() const {
    return m_size;
}

void Types::PhotoSize::setType(const QString &type) {
    m_type = type;
}

QString Types::PhotoSize::type() const {
    return m_type;
}

void Types::PhotoSize::setW(qint32 w) {
    m_w = w;
}

qint32 Types::PhotoSize::w() const {
    return m_w;
}

bool Types::PhotoSize::operator ==(const PhotoSize &b) {
    return m_bytes == b.m_bytes &&
           m_h == b.m_h &&
           m_location == b.m_location &&
           m_size == b.m_size &&
           m_type == b.m_type &&
           m_w == b.m_w;
}

void Types::PhotoSize::setClassType(PhotoSize::PhotoSizeType classType) {
    m_classType = classType;
}

Types::PhotoSize::PhotoSizeType Types::PhotoSize::classType() const {
    return m_classType;
}

bool Types::PhotoSize::fetch(InboundPkt *in) {
    LQTG_FETCH_LOG;
    int x = in->fetchInt();
    switch(x) {
    case typePhotoSizeEmpty: {
        m_type = in->fetchQString();
        m_classType = static_cast<PhotoSizeType>(x);
        return true;
    }
        break;
    
    case typePhotoSize: {
        m_type = in->fetchQString();
        m_location.fetch(in);
        m_w = in->fetchInt();
        m_h = in->fetchInt();
        m_size = in->fetchInt();
        m_classType = static_cast<PhotoSizeType>(x);
        return true;
    }
        break;
    
    case typePhotoCachedSize: {
        m_type = in->fetchQString();
        m_location.fetch(in);
        m_w = in->fetchInt();
        m_h = in->fetchInt();
        m_bytes = in->fetchBytes();
        m_classType = static_cast<PhotoSizeType>(x);
        return true;
    }
        break;
    
    default:
        LQTG_FETCH_ASSERT;
        return false;
    }
}

bool Types::PhotoSize::push(OutboundPkt *out) const {
    out->appendInt(m_classType);
    switch(m_classType) {
    case typePhotoSizeEmpty: {
        out->appendQString(m_type);
        return true;
    }
        break;
    
    case typePhotoSize: {
        out->appendQString(m_type);
        m_location.push(out);
        out->appendInt(m_w);
        out->appendInt(m_h);
        out->appendInt(m_size);
        return true;
    }
        break;
    
    case typePhotoCachedSize: {
        out->appendQString(m_type);
        m_location.push(out);
        out->appendInt(m_w);
        out->appendInt(m_h);
        out->appendBytes(m_bytes);
        return true;
    }
        break;
    
    default:
        return false;
    }
}

