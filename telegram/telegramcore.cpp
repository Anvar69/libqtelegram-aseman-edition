// This file generated by libqtelegram-code-generator.
// You can download it from: https://github.com/Aseman-Land/libqtelegram-code-generator
// DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN

#include "telegramcore.h"
#include <QDebug>

TelegramCore::TelegramCore(QObject *parent) :
    QObject(parent)
{
}

void TelegramCore::setApi(TelegramApi *api)
{
    mApi = api;

    connect(mApi, SIGNAL(accountRegisterDeviceAnswer(qint64,qint32,QString,QString,QString,QString,bool,QString)), this, SLOT(onAccountRegisterDeviceAnswer(qint64,qint32,QString,QString,QString,QString,bool,QString)));
    connect(mApi, SIGNAL(accountRegisterDeviceError(qint64,QString,QString)), this, SLOT(0nAccountRegisterDeviceError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(accountUnregisterDeviceAnswer(qint64,qint32,QString)), this, SLOT(onAccountUnregisterDeviceAnswer(qint64,qint32,QString)));
    connect(mApi, SIGNAL(accountUnregisterDeviceError(qint64,QString,QString)), this, SLOT(0nAccountUnregisterDeviceError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(accountUpdateNotifySettingsAnswer(qint64,InputNotifyPeer,InputPeerNotifySettings)), this, SLOT(onAccountUpdateNotifySettingsAnswer(qint64,InputNotifyPeer,InputPeerNotifySettings)));
    connect(mApi, SIGNAL(accountUpdateNotifySettingsError(qint64,QString,QString)), this, SLOT(0nAccountUpdateNotifySettingsError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(accountGetNotifySettingsAnswer(qint64,InputNotifyPeer)), this, SLOT(onAccountGetNotifySettingsAnswer(qint64,InputNotifyPeer)));
    connect(mApi, SIGNAL(accountGetNotifySettingsError(qint64,QString,QString)), this, SLOT(0nAccountGetNotifySettingsError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(accountResetNotifySettingsAnswer(qint64)), this, SLOT(onAccountResetNotifySettingsAnswer(qint64)));
    connect(mApi, SIGNAL(accountResetNotifySettingsError(qint64,QString,QString)), this, SLOT(0nAccountResetNotifySettingsError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(accountUpdateProfileAnswer(qint64,QString,QString)), this, SLOT(onAccountUpdateProfileAnswer(qint64,QString,QString)));
    connect(mApi, SIGNAL(accountUpdateProfileError(qint64,QString,QString)), this, SLOT(0nAccountUpdateProfileError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(accountUpdateStatusAnswer(qint64,bool)), this, SLOT(onAccountUpdateStatusAnswer(qint64,bool)));
    connect(mApi, SIGNAL(accountUpdateStatusError(qint64,QString,QString)), this, SLOT(0nAccountUpdateStatusError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(accountGetWallPapersAnswer(qint64)), this, SLOT(onAccountGetWallPapersAnswer(qint64)));
    connect(mApi, SIGNAL(accountGetWallPapersError(qint64,QString,QString)), this, SLOT(0nAccountGetWallPapersError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(accountReportPeerAnswer(qint64,InputPeer,ReportReason)), this, SLOT(onAccountReportPeerAnswer(qint64,InputPeer,ReportReason)));
    connect(mApi, SIGNAL(accountReportPeerError(qint64,QString,QString)), this, SLOT(0nAccountReportPeerError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(accountCheckUsernameAnswer(qint64,QString)), this, SLOT(onAccountCheckUsernameAnswer(qint64,QString)));
    connect(mApi, SIGNAL(accountCheckUsernameError(qint64,QString,QString)), this, SLOT(0nAccountCheckUsernameError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(accountUpdateUsernameAnswer(qint64,QString)), this, SLOT(onAccountUpdateUsernameAnswer(qint64,QString)));
    connect(mApi, SIGNAL(accountUpdateUsernameError(qint64,QString,QString)), this, SLOT(0nAccountUpdateUsernameError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(accountGetPrivacyAnswer(qint64,InputPrivacyKey)), this, SLOT(onAccountGetPrivacyAnswer(qint64,InputPrivacyKey)));
    connect(mApi, SIGNAL(accountGetPrivacyError(qint64,QString,QString)), this, SLOT(0nAccountGetPrivacyError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(accountSetPrivacyAnswer(qint64,InputPrivacyKey,QList<InputPrivacyRule>)), this, SLOT(onAccountSetPrivacyAnswer(qint64,InputPrivacyKey,QList<InputPrivacyRule>)));
    connect(mApi, SIGNAL(accountSetPrivacyError(qint64,QString,QString)), this, SLOT(0nAccountSetPrivacyError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(accountDeleteAccountAnswer(qint64,QString)), this, SLOT(onAccountDeleteAccountAnswer(qint64,QString)));
    connect(mApi, SIGNAL(accountDeleteAccountError(qint64,QString,QString)), this, SLOT(0nAccountDeleteAccountError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(accountGetAccountTTLAnswer(qint64)), this, SLOT(onAccountGetAccountTTLAnswer(qint64)));
    connect(mApi, SIGNAL(accountGetAccountTTLError(qint64,QString,QString)), this, SLOT(0nAccountGetAccountTTLError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(accountSetAccountTTLAnswer(qint64,AccountDaysTTL)), this, SLOT(onAccountSetAccountTTLAnswer(qint64,AccountDaysTTL)));
    connect(mApi, SIGNAL(accountSetAccountTTLError(qint64,QString,QString)), this, SLOT(0nAccountSetAccountTTLError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(accountSendChangePhoneCodeAnswer(qint64,QString)), this, SLOT(onAccountSendChangePhoneCodeAnswer(qint64,QString)));
    connect(mApi, SIGNAL(accountSendChangePhoneCodeError(qint64,QString,QString)), this, SLOT(0nAccountSendChangePhoneCodeError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(accountChangePhoneAnswer(qint64,QString,QString,QString)), this, SLOT(onAccountChangePhoneAnswer(qint64,QString,QString,QString)));
    connect(mApi, SIGNAL(accountChangePhoneError(qint64,QString,QString)), this, SLOT(0nAccountChangePhoneError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(accountUpdateDeviceLockedAnswer(qint64,qint32)), this, SLOT(onAccountUpdateDeviceLockedAnswer(qint64,qint32)));
    connect(mApi, SIGNAL(accountUpdateDeviceLockedError(qint64,QString,QString)), this, SLOT(0nAccountUpdateDeviceLockedError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(accountGetAuthorizationsAnswer(qint64)), this, SLOT(onAccountGetAuthorizationsAnswer(qint64)));
    connect(mApi, SIGNAL(accountGetAuthorizationsError(qint64,QString,QString)), this, SLOT(0nAccountGetAuthorizationsError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(accountResetAuthorizationAnswer(qint64,qint64)), this, SLOT(onAccountResetAuthorizationAnswer(qint64,qint64)));
    connect(mApi, SIGNAL(accountResetAuthorizationError(qint64,QString,QString)), this, SLOT(0nAccountResetAuthorizationError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(accountGetPasswordAnswer(qint64)), this, SLOT(onAccountGetPasswordAnswer(qint64)));
    connect(mApi, SIGNAL(accountGetPasswordError(qint64,QString,QString)), this, SLOT(0nAccountGetPasswordError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(accountGetPasswordSettingsAnswer(qint64,QByteArray)), this, SLOT(onAccountGetPasswordSettingsAnswer(qint64,QByteArray)));
    connect(mApi, SIGNAL(accountGetPasswordSettingsError(qint64,QString,QString)), this, SLOT(0nAccountGetPasswordSettingsError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(accountUpdatePasswordSettingsAnswer(qint64,QByteArray,AccountPasswordInputSettings)), this, SLOT(onAccountUpdatePasswordSettingsAnswer(qint64,QByteArray,AccountPasswordInputSettings)));
    connect(mApi, SIGNAL(accountUpdatePasswordSettingsError(qint64,QString,QString)), this, SLOT(0nAccountUpdatePasswordSettingsError(qint64,QString,QString)));
    
    
    connect(mApi, SIGNAL(authCheckPhoneAnswer(qint64,QString)), this, SLOT(onAuthCheckPhoneAnswer(qint64,QString)));
    connect(mApi, SIGNAL(authCheckPhoneError(qint64,QString,QString)), this, SLOT(0nAuthCheckPhoneError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(authSendCodeAnswer(qint64,QString,qint32,qint32,QString,QString)), this, SLOT(onAuthSendCodeAnswer(qint64,QString,qint32,qint32,QString,QString)));
    connect(mApi, SIGNAL(authSendCodeError(qint64,QString,QString)), this, SLOT(0nAuthSendCodeError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(authSendCallAnswer(qint64,QString,QString)), this, SLOT(onAuthSendCallAnswer(qint64,QString,QString)));
    connect(mApi, SIGNAL(authSendCallError(qint64,QString,QString)), this, SLOT(0nAuthSendCallError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(authSignUpAnswer(qint64,QString,QString,QString,QString,QString)), this, SLOT(onAuthSignUpAnswer(qint64,QString,QString,QString,QString,QString)));
    connect(mApi, SIGNAL(authSignUpError(qint64,QString,QString)), this, SLOT(0nAuthSignUpError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(authSignInAnswer(qint64,QString,QString,QString)), this, SLOT(onAuthSignInAnswer(qint64,QString,QString,QString)));
    connect(mApi, SIGNAL(authSignInError(qint64,QString,QString)), this, SLOT(0nAuthSignInError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(authLogOutAnswer(qint64)), this, SLOT(onAuthLogOutAnswer(qint64)));
    connect(mApi, SIGNAL(authLogOutError(qint64,QString,QString)), this, SLOT(0nAuthLogOutError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(authResetAuthorizationsAnswer(qint64)), this, SLOT(onAuthResetAuthorizationsAnswer(qint64)));
    connect(mApi, SIGNAL(authResetAuthorizationsError(qint64,QString,QString)), this, SLOT(0nAuthResetAuthorizationsError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(authSendInvitesAnswer(qint64,QList<QString>,QString)), this, SLOT(onAuthSendInvitesAnswer(qint64,QList<QString>,QString)));
    connect(mApi, SIGNAL(authSendInvitesError(qint64,QString,QString)), this, SLOT(0nAuthSendInvitesError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(authExportAuthorizationAnswer(qint64,qint32)), this, SLOT(onAuthExportAuthorizationAnswer(qint64,qint32)));
    connect(mApi, SIGNAL(authExportAuthorizationError(qint64,QString,QString)), this, SLOT(0nAuthExportAuthorizationError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(authImportAuthorizationAnswer(qint64,qint32,QByteArray)), this, SLOT(onAuthImportAuthorizationAnswer(qint64,qint32,QByteArray)));
    connect(mApi, SIGNAL(authImportAuthorizationError(qint64,QString,QString)), this, SLOT(0nAuthImportAuthorizationError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(authBindTempAuthKeyAnswer(qint64,qint64,qint64,qint32,QByteArray)), this, SLOT(onAuthBindTempAuthKeyAnswer(qint64,qint64,qint64,qint32,QByteArray)));
    connect(mApi, SIGNAL(authBindTempAuthKeyError(qint64,QString,QString)), this, SLOT(0nAuthBindTempAuthKeyError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(authSendSmsAnswer(qint64,QString,QString)), this, SLOT(onAuthSendSmsAnswer(qint64,QString,QString)));
    connect(mApi, SIGNAL(authSendSmsError(qint64,QString,QString)), this, SLOT(0nAuthSendSmsError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(authImportBotAuthorizationAnswer(qint64,qint32,qint32,QString,QString)), this, SLOT(onAuthImportBotAuthorizationAnswer(qint64,qint32,qint32,QString,QString)));
    connect(mApi, SIGNAL(authImportBotAuthorizationError(qint64,QString,QString)), this, SLOT(0nAuthImportBotAuthorizationError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(authCheckPasswordAnswer(qint64,QByteArray)), this, SLOT(onAuthCheckPasswordAnswer(qint64,QByteArray)));
    connect(mApi, SIGNAL(authCheckPasswordError(qint64,QString,QString)), this, SLOT(0nAuthCheckPasswordError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(authRequestPasswordRecoveryAnswer(qint64)), this, SLOT(onAuthRequestPasswordRecoveryAnswer(qint64)));
    connect(mApi, SIGNAL(authRequestPasswordRecoveryError(qint64,QString,QString)), this, SLOT(0nAuthRequestPasswordRecoveryError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(authRecoverPasswordAnswer(qint64,QString)), this, SLOT(onAuthRecoverPasswordAnswer(qint64,QString)));
    connect(mApi, SIGNAL(authRecoverPasswordError(qint64,QString,QString)), this, SLOT(0nAuthRecoverPasswordError(qint64,QString,QString)));
    
    
    connect(mApi, SIGNAL(channelsGetDialogsAnswer(qint64,qint32,qint32)), this, SLOT(onChannelsGetDialogsAnswer(qint64,qint32,qint32)));
    connect(mApi, SIGNAL(channelsGetDialogsError(qint64,QString,QString)), this, SLOT(0nChannelsGetDialogsError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(channelsGetImportantHistoryAnswer(qint64,InputChannel,qint32,qint32,qint32,qint32,qint32)), this, SLOT(onChannelsGetImportantHistoryAnswer(qint64,InputChannel,qint32,qint32,qint32,qint32,qint32)));
    connect(mApi, SIGNAL(channelsGetImportantHistoryError(qint64,QString,QString)), this, SLOT(0nChannelsGetImportantHistoryError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(channelsReadHistoryAnswer(qint64,InputChannel,qint32)), this, SLOT(onChannelsReadHistoryAnswer(qint64,InputChannel,qint32)));
    connect(mApi, SIGNAL(channelsReadHistoryError(qint64,QString,QString)), this, SLOT(0nChannelsReadHistoryError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(channelsDeleteMessagesAnswer(qint64,InputChannel,QList<qint32>)), this, SLOT(onChannelsDeleteMessagesAnswer(qint64,InputChannel,QList<qint32>)));
    connect(mApi, SIGNAL(channelsDeleteMessagesError(qint64,QString,QString)), this, SLOT(0nChannelsDeleteMessagesError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(channelsDeleteUserHistoryAnswer(qint64,InputChannel,InputUser)), this, SLOT(onChannelsDeleteUserHistoryAnswer(qint64,InputChannel,InputUser)));
    connect(mApi, SIGNAL(channelsDeleteUserHistoryError(qint64,QString,QString)), this, SLOT(0nChannelsDeleteUserHistoryError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(channelsReportSpamAnswer(qint64,InputChannel,InputUser,QList<qint32>)), this, SLOT(onChannelsReportSpamAnswer(qint64,InputChannel,InputUser,QList<qint32>)));
    connect(mApi, SIGNAL(channelsReportSpamError(qint64,QString,QString)), this, SLOT(0nChannelsReportSpamError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(channelsGetMessagesAnswer(qint64,InputChannel,QList<qint32>)), this, SLOT(onChannelsGetMessagesAnswer(qint64,InputChannel,QList<qint32>)));
    connect(mApi, SIGNAL(channelsGetMessagesError(qint64,QString,QString)), this, SLOT(0nChannelsGetMessagesError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(channelsGetParticipantsAnswer(qint64,InputChannel,ChannelParticipantsFilter,qint32,qint32)), this, SLOT(onChannelsGetParticipantsAnswer(qint64,InputChannel,ChannelParticipantsFilter,qint32,qint32)));
    connect(mApi, SIGNAL(channelsGetParticipantsError(qint64,QString,QString)), this, SLOT(0nChannelsGetParticipantsError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(channelsGetParticipantAnswer(qint64,InputChannel,InputUser)), this, SLOT(onChannelsGetParticipantAnswer(qint64,InputChannel,InputUser)));
    connect(mApi, SIGNAL(channelsGetParticipantError(qint64,QString,QString)), this, SLOT(0nChannelsGetParticipantError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(channelsGetChannelsAnswer(qint64,QList<InputChannel>)), this, SLOT(onChannelsGetChannelsAnswer(qint64,QList<InputChannel>)));
    connect(mApi, SIGNAL(channelsGetChannelsError(qint64,QString,QString)), this, SLOT(0nChannelsGetChannelsError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(channelsGetFullChannelAnswer(qint64,InputChannel)), this, SLOT(onChannelsGetFullChannelAnswer(qint64,InputChannel)));
    connect(mApi, SIGNAL(channelsGetFullChannelError(qint64,QString,QString)), this, SLOT(0nChannelsGetFullChannelError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(channelsCreateChannelAnswer(qint64,bool,bool,QString,QString)), this, SLOT(onChannelsCreateChannelAnswer(qint64,bool,bool,QString,QString)));
    connect(mApi, SIGNAL(channelsCreateChannelError(qint64,QString,QString)), this, SLOT(0nChannelsCreateChannelError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(channelsEditAboutAnswer(qint64,InputChannel,QString)), this, SLOT(onChannelsEditAboutAnswer(qint64,InputChannel,QString)));
    connect(mApi, SIGNAL(channelsEditAboutError(qint64,QString,QString)), this, SLOT(0nChannelsEditAboutError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(channelsEditAdminAnswer(qint64,InputChannel,InputUser,ChannelParticipantRole)), this, SLOT(onChannelsEditAdminAnswer(qint64,InputChannel,InputUser,ChannelParticipantRole)));
    connect(mApi, SIGNAL(channelsEditAdminError(qint64,QString,QString)), this, SLOT(0nChannelsEditAdminError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(channelsEditTitleAnswer(qint64,InputChannel,QString)), this, SLOT(onChannelsEditTitleAnswer(qint64,InputChannel,QString)));
    connect(mApi, SIGNAL(channelsEditTitleError(qint64,QString,QString)), this, SLOT(0nChannelsEditTitleError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(channelsEditPhotoAnswer(qint64,InputChannel,InputChatPhoto)), this, SLOT(onChannelsEditPhotoAnswer(qint64,InputChannel,InputChatPhoto)));
    connect(mApi, SIGNAL(channelsEditPhotoError(qint64,QString,QString)), this, SLOT(0nChannelsEditPhotoError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(channelsToggleCommentsAnswer(qint64,InputChannel,bool)), this, SLOT(onChannelsToggleCommentsAnswer(qint64,InputChannel,bool)));
    connect(mApi, SIGNAL(channelsToggleCommentsError(qint64,QString,QString)), this, SLOT(0nChannelsToggleCommentsError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(channelsCheckUsernameAnswer(qint64,InputChannel,QString)), this, SLOT(onChannelsCheckUsernameAnswer(qint64,InputChannel,QString)));
    connect(mApi, SIGNAL(channelsCheckUsernameError(qint64,QString,QString)), this, SLOT(0nChannelsCheckUsernameError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(channelsUpdateUsernameAnswer(qint64,InputChannel,QString)), this, SLOT(onChannelsUpdateUsernameAnswer(qint64,InputChannel,QString)));
    connect(mApi, SIGNAL(channelsUpdateUsernameError(qint64,QString,QString)), this, SLOT(0nChannelsUpdateUsernameError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(channelsJoinChannelAnswer(qint64,InputChannel)), this, SLOT(onChannelsJoinChannelAnswer(qint64,InputChannel)));
    connect(mApi, SIGNAL(channelsJoinChannelError(qint64,QString,QString)), this, SLOT(0nChannelsJoinChannelError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(channelsLeaveChannelAnswer(qint64,InputChannel)), this, SLOT(onChannelsLeaveChannelAnswer(qint64,InputChannel)));
    connect(mApi, SIGNAL(channelsLeaveChannelError(qint64,QString,QString)), this, SLOT(0nChannelsLeaveChannelError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(channelsInviteToChannelAnswer(qint64,InputChannel,QList<InputUser>)), this, SLOT(onChannelsInviteToChannelAnswer(qint64,InputChannel,QList<InputUser>)));
    connect(mApi, SIGNAL(channelsInviteToChannelError(qint64,QString,QString)), this, SLOT(0nChannelsInviteToChannelError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(channelsKickFromChannelAnswer(qint64,InputChannel,InputUser,bool)), this, SLOT(onChannelsKickFromChannelAnswer(qint64,InputChannel,InputUser,bool)));
    connect(mApi, SIGNAL(channelsKickFromChannelError(qint64,QString,QString)), this, SLOT(0nChannelsKickFromChannelError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(channelsExportInviteAnswer(qint64,InputChannel)), this, SLOT(onChannelsExportInviteAnswer(qint64,InputChannel)));
    connect(mApi, SIGNAL(channelsExportInviteError(qint64,QString,QString)), this, SLOT(0nChannelsExportInviteError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(channelsDeleteChannelAnswer(qint64,InputChannel)), this, SLOT(onChannelsDeleteChannelAnswer(qint64,InputChannel)));
    connect(mApi, SIGNAL(channelsDeleteChannelError(qint64,QString,QString)), this, SLOT(0nChannelsDeleteChannelError(qint64,QString,QString)));
    
    
    connect(mApi, SIGNAL(contactsGetStatusesAnswer(qint64)), this, SLOT(onContactsGetStatusesAnswer(qint64)));
    connect(mApi, SIGNAL(contactsGetStatusesError(qint64,QString,QString)), this, SLOT(0nContactsGetStatusesError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(contactsGetContactsAnswer(qint64,QString)), this, SLOT(onContactsGetContactsAnswer(qint64,QString)));
    connect(mApi, SIGNAL(contactsGetContactsError(qint64,QString,QString)), this, SLOT(0nContactsGetContactsError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(contactsImportContactsAnswer(qint64,QList<InputContact>,bool)), this, SLOT(onContactsImportContactsAnswer(qint64,QList<InputContact>,bool)));
    connect(mApi, SIGNAL(contactsImportContactsError(qint64,QString,QString)), this, SLOT(0nContactsImportContactsError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(contactsGetSuggestedAnswer(qint64,qint32)), this, SLOT(onContactsGetSuggestedAnswer(qint64,qint32)));
    connect(mApi, SIGNAL(contactsGetSuggestedError(qint64,QString,QString)), this, SLOT(0nContactsGetSuggestedError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(contactsDeleteContactAnswer(qint64,InputUser)), this, SLOT(onContactsDeleteContactAnswer(qint64,InputUser)));
    connect(mApi, SIGNAL(contactsDeleteContactError(qint64,QString,QString)), this, SLOT(0nContactsDeleteContactError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(contactsDeleteContactsAnswer(qint64,QList<InputUser>)), this, SLOT(onContactsDeleteContactsAnswer(qint64,QList<InputUser>)));
    connect(mApi, SIGNAL(contactsDeleteContactsError(qint64,QString,QString)), this, SLOT(0nContactsDeleteContactsError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(contactsBlockAnswer(qint64,InputUser)), this, SLOT(onContactsBlockAnswer(qint64,InputUser)));
    connect(mApi, SIGNAL(contactsBlockError(qint64,QString,QString)), this, SLOT(0nContactsBlockError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(contactsUnblockAnswer(qint64,InputUser)), this, SLOT(onContactsUnblockAnswer(qint64,InputUser)));
    connect(mApi, SIGNAL(contactsUnblockError(qint64,QString,QString)), this, SLOT(0nContactsUnblockError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(contactsGetBlockedAnswer(qint64,qint32,qint32)), this, SLOT(onContactsGetBlockedAnswer(qint64,qint32,qint32)));
    connect(mApi, SIGNAL(contactsGetBlockedError(qint64,QString,QString)), this, SLOT(0nContactsGetBlockedError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(contactsExportCardAnswer(qint64)), this, SLOT(onContactsExportCardAnswer(qint64)));
    connect(mApi, SIGNAL(contactsExportCardError(qint64,QString,QString)), this, SLOT(0nContactsExportCardError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(contactsImportCardAnswer(qint64,QList<qint32>)), this, SLOT(onContactsImportCardAnswer(qint64,QList<qint32>)));
    connect(mApi, SIGNAL(contactsImportCardError(qint64,QString,QString)), this, SLOT(0nContactsImportCardError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(contactsSearchAnswer(qint64,QString,qint32)), this, SLOT(onContactsSearchAnswer(qint64,QString,qint32)));
    connect(mApi, SIGNAL(contactsSearchError(qint64,QString,QString)), this, SLOT(0nContactsSearchError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(contactsResolveUsernameAnswer(qint64,QString)), this, SLOT(onContactsResolveUsernameAnswer(qint64,QString)));
    connect(mApi, SIGNAL(contactsResolveUsernameError(qint64,QString,QString)), this, SLOT(0nContactsResolveUsernameError(qint64,QString,QString)));
    
    
    connect(mApi, SIGNAL(helpGetConfigAnswer(qint64)), this, SLOT(onHelpGetConfigAnswer(qint64)));
    connect(mApi, SIGNAL(helpGetConfigError(qint64,QString,QString)), this, SLOT(0nHelpGetConfigError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(helpGetNearestDcAnswer(qint64)), this, SLOT(onHelpGetNearestDcAnswer(qint64)));
    connect(mApi, SIGNAL(helpGetNearestDcError(qint64,QString,QString)), this, SLOT(0nHelpGetNearestDcError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(helpGetAppUpdateAnswer(qint64,QString,QString,QString,QString)), this, SLOT(onHelpGetAppUpdateAnswer(qint64,QString,QString,QString,QString)));
    connect(mApi, SIGNAL(helpGetAppUpdateError(qint64,QString,QString)), this, SLOT(0nHelpGetAppUpdateError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(helpSaveAppLogAnswer(qint64,QList<InputAppEvent>)), this, SLOT(onHelpSaveAppLogAnswer(qint64,QList<InputAppEvent>)));
    connect(mApi, SIGNAL(helpSaveAppLogError(qint64,QString,QString)), this, SLOT(0nHelpSaveAppLogError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(helpGetInviteTextAnswer(qint64,QString)), this, SLOT(onHelpGetInviteTextAnswer(qint64,QString)));
    connect(mApi, SIGNAL(helpGetInviteTextError(qint64,QString,QString)), this, SLOT(0nHelpGetInviteTextError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(helpGetSupportAnswer(qint64)), this, SLOT(onHelpGetSupportAnswer(qint64)));
    connect(mApi, SIGNAL(helpGetSupportError(qint64,QString,QString)), this, SLOT(0nHelpGetSupportError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(helpGetAppChangelogAnswer(qint64,QString,QString,QString,QString)), this, SLOT(onHelpGetAppChangelogAnswer(qint64,QString,QString,QString,QString)));
    connect(mApi, SIGNAL(helpGetAppChangelogError(qint64,QString,QString)), this, SLOT(0nHelpGetAppChangelogError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(helpGetTermsOfServiceAnswer(qint64,QString)), this, SLOT(onHelpGetTermsOfServiceAnswer(qint64,QString)));
    connect(mApi, SIGNAL(helpGetTermsOfServiceError(qint64,QString,QString)), this, SLOT(0nHelpGetTermsOfServiceError(qint64,QString,QString)));
    
    
    connect(mApi, SIGNAL(messagesGetMessagesAnswer(qint64,QList<qint32>)), this, SLOT(onMessagesGetMessagesAnswer(qint64,QList<qint32>)));
    connect(mApi, SIGNAL(messagesGetMessagesError(qint64,QString,QString)), this, SLOT(0nMessagesGetMessagesError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesGetDialogsAnswer(qint64,qint32,qint32,InputPeer,qint32)), this, SLOT(onMessagesGetDialogsAnswer(qint64,qint32,qint32,InputPeer,qint32)));
    connect(mApi, SIGNAL(messagesGetDialogsError(qint64,QString,QString)), this, SLOT(0nMessagesGetDialogsError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesGetHistoryAnswer(qint64,InputPeer,qint32,qint32,qint32,qint32,qint32)), this, SLOT(onMessagesGetHistoryAnswer(qint64,InputPeer,qint32,qint32,qint32,qint32,qint32)));
    connect(mApi, SIGNAL(messagesGetHistoryError(qint64,QString,QString)), this, SLOT(0nMessagesGetHistoryError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesSearchAnswer(qint64,bool,InputPeer,QString,MessagesFilter,qint32,qint32,qint32,qint32,qint32)), this, SLOT(onMessagesSearchAnswer(qint64,bool,InputPeer,QString,MessagesFilter,qint32,qint32,qint32,qint32,qint32)));
    connect(mApi, SIGNAL(messagesSearchError(qint64,QString,QString)), this, SLOT(0nMessagesSearchError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesReadHistoryAnswer(qint64,InputPeer,qint32)), this, SLOT(onMessagesReadHistoryAnswer(qint64,InputPeer,qint32)));
    connect(mApi, SIGNAL(messagesReadHistoryError(qint64,QString,QString)), this, SLOT(0nMessagesReadHistoryError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesDeleteHistoryAnswer(qint64,InputPeer,qint32)), this, SLOT(onMessagesDeleteHistoryAnswer(qint64,InputPeer,qint32)));
    connect(mApi, SIGNAL(messagesDeleteHistoryError(qint64,QString,QString)), this, SLOT(0nMessagesDeleteHistoryError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesDeleteMessagesAnswer(qint64,QList<qint32>)), this, SLOT(onMessagesDeleteMessagesAnswer(qint64,QList<qint32>)));
    connect(mApi, SIGNAL(messagesDeleteMessagesError(qint64,QString,QString)), this, SLOT(0nMessagesDeleteMessagesError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesReceivedMessagesAnswer(qint64,qint32)), this, SLOT(onMessagesReceivedMessagesAnswer(qint64,qint32)));
    connect(mApi, SIGNAL(messagesReceivedMessagesError(qint64,QString,QString)), this, SLOT(0nMessagesReceivedMessagesError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesSetTypingAnswer(qint64,InputPeer,SendMessageAction)), this, SLOT(onMessagesSetTypingAnswer(qint64,InputPeer,SendMessageAction)));
    connect(mApi, SIGNAL(messagesSetTypingError(qint64,QString,QString)), this, SLOT(0nMessagesSetTypingError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesSendMessageAnswer(qint64,bool,bool,InputPeer,qint32,QString,qint64,ReplyMarkup,QList<MessageEntity>)), this, SLOT(onMessagesSendMessageAnswer(qint64,bool,bool,InputPeer,qint32,QString,qint64,ReplyMarkup,QList<MessageEntity>)));
    connect(mApi, SIGNAL(messagesSendMessageError(qint64,QString,QString)), this, SLOT(0nMessagesSendMessageError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesSendMediaAnswer(qint64,bool,InputPeer,qint32,InputMedia,qint64,ReplyMarkup)), this, SLOT(onMessagesSendMediaAnswer(qint64,bool,InputPeer,qint32,InputMedia,qint64,ReplyMarkup)));
    connect(mApi, SIGNAL(messagesSendMediaError(qint64,QString,QString)), this, SLOT(0nMessagesSendMediaError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesForwardMessagesAnswer(qint64,bool,InputPeer,QList<qint32>,QList<qint64>,InputPeer)), this, SLOT(onMessagesForwardMessagesAnswer(qint64,bool,InputPeer,QList<qint32>,QList<qint64>,InputPeer)));
    connect(mApi, SIGNAL(messagesForwardMessagesError(qint64,QString,QString)), this, SLOT(0nMessagesForwardMessagesError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesReportSpamAnswer(qint64,InputPeer)), this, SLOT(onMessagesReportSpamAnswer(qint64,InputPeer)));
    connect(mApi, SIGNAL(messagesReportSpamError(qint64,QString,QString)), this, SLOT(0nMessagesReportSpamError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesGetChatsAnswer(qint64,QList<qint32>)), this, SLOT(onMessagesGetChatsAnswer(qint64,QList<qint32>)));
    connect(mApi, SIGNAL(messagesGetChatsError(qint64,QString,QString)), this, SLOT(0nMessagesGetChatsError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesGetFullChatAnswer(qint64,qint32)), this, SLOT(onMessagesGetFullChatAnswer(qint64,qint32)));
    connect(mApi, SIGNAL(messagesGetFullChatError(qint64,QString,QString)), this, SLOT(0nMessagesGetFullChatError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesEditChatTitleAnswer(qint64,qint32,QString)), this, SLOT(onMessagesEditChatTitleAnswer(qint64,qint32,QString)));
    connect(mApi, SIGNAL(messagesEditChatTitleError(qint64,QString,QString)), this, SLOT(0nMessagesEditChatTitleError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesEditChatPhotoAnswer(qint64,qint32,InputChatPhoto)), this, SLOT(onMessagesEditChatPhotoAnswer(qint64,qint32,InputChatPhoto)));
    connect(mApi, SIGNAL(messagesEditChatPhotoError(qint64,QString,QString)), this, SLOT(0nMessagesEditChatPhotoError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesAddChatUserAnswer(qint64,qint32,InputUser,qint32)), this, SLOT(onMessagesAddChatUserAnswer(qint64,qint32,InputUser,qint32)));
    connect(mApi, SIGNAL(messagesAddChatUserError(qint64,QString,QString)), this, SLOT(0nMessagesAddChatUserError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesDeleteChatUserAnswer(qint64,qint32,InputUser)), this, SLOT(onMessagesDeleteChatUserAnswer(qint64,qint32,InputUser)));
    connect(mApi, SIGNAL(messagesDeleteChatUserError(qint64,QString,QString)), this, SLOT(0nMessagesDeleteChatUserError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesCreateChatAnswer(qint64,QList<InputUser>,QString)), this, SLOT(onMessagesCreateChatAnswer(qint64,QList<InputUser>,QString)));
    connect(mApi, SIGNAL(messagesCreateChatError(qint64,QString,QString)), this, SLOT(0nMessagesCreateChatError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesForwardMessageAnswer(qint64,InputPeer,qint32,qint64)), this, SLOT(onMessagesForwardMessageAnswer(qint64,InputPeer,qint32,qint64)));
    connect(mApi, SIGNAL(messagesForwardMessageError(qint64,QString,QString)), this, SLOT(0nMessagesForwardMessageError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesSendBroadcastAnswer(qint64,QList<InputUser>,QList<qint64>,QString,InputMedia)), this, SLOT(onMessagesSendBroadcastAnswer(qint64,QList<InputUser>,QList<qint64>,QString,InputMedia)));
    connect(mApi, SIGNAL(messagesSendBroadcastError(qint64,QString,QString)), this, SLOT(0nMessagesSendBroadcastError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesGetDhConfigAnswer(qint64,qint32,qint32)), this, SLOT(onMessagesGetDhConfigAnswer(qint64,qint32,qint32)));
    connect(mApi, SIGNAL(messagesGetDhConfigError(qint64,QString,QString)), this, SLOT(0nMessagesGetDhConfigError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesRequestEncryptionAnswer(qint64,InputUser,qint32,QByteArray)), this, SLOT(onMessagesRequestEncryptionAnswer(qint64,InputUser,qint32,QByteArray)));
    connect(mApi, SIGNAL(messagesRequestEncryptionError(qint64,QString,QString)), this, SLOT(0nMessagesRequestEncryptionError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesAcceptEncryptionAnswer(qint64,InputEncryptedChat,QByteArray,qint64)), this, SLOT(onMessagesAcceptEncryptionAnswer(qint64,InputEncryptedChat,QByteArray,qint64)));
    connect(mApi, SIGNAL(messagesAcceptEncryptionError(qint64,QString,QString)), this, SLOT(0nMessagesAcceptEncryptionError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesDiscardEncryptionAnswer(qint64,qint32)), this, SLOT(onMessagesDiscardEncryptionAnswer(qint64,qint32)));
    connect(mApi, SIGNAL(messagesDiscardEncryptionError(qint64,QString,QString)), this, SLOT(0nMessagesDiscardEncryptionError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesSetEncryptedTypingAnswer(qint64,InputEncryptedChat,bool)), this, SLOT(onMessagesSetEncryptedTypingAnswer(qint64,InputEncryptedChat,bool)));
    connect(mApi, SIGNAL(messagesSetEncryptedTypingError(qint64,QString,QString)), this, SLOT(0nMessagesSetEncryptedTypingError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesReadEncryptedHistoryAnswer(qint64,InputEncryptedChat,qint32)), this, SLOT(onMessagesReadEncryptedHistoryAnswer(qint64,InputEncryptedChat,qint32)));
    connect(mApi, SIGNAL(messagesReadEncryptedHistoryError(qint64,QString,QString)), this, SLOT(0nMessagesReadEncryptedHistoryError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesSendEncryptedAnswer(qint64,InputEncryptedChat,qint64,QByteArray)), this, SLOT(onMessagesSendEncryptedAnswer(qint64,InputEncryptedChat,qint64,QByteArray)));
    connect(mApi, SIGNAL(messagesSendEncryptedError(qint64,QString,QString)), this, SLOT(0nMessagesSendEncryptedError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesSendEncryptedFileAnswer(qint64,InputEncryptedChat,qint64,QByteArray,InputEncryptedFile)), this, SLOT(onMessagesSendEncryptedFileAnswer(qint64,InputEncryptedChat,qint64,QByteArray,InputEncryptedFile)));
    connect(mApi, SIGNAL(messagesSendEncryptedFileError(qint64,QString,QString)), this, SLOT(0nMessagesSendEncryptedFileError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesSendEncryptedServiceAnswer(qint64,InputEncryptedChat,qint64,QByteArray)), this, SLOT(onMessagesSendEncryptedServiceAnswer(qint64,InputEncryptedChat,qint64,QByteArray)));
    connect(mApi, SIGNAL(messagesSendEncryptedServiceError(qint64,QString,QString)), this, SLOT(0nMessagesSendEncryptedServiceError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesReceivedQueueAnswer(qint64,qint32)), this, SLOT(onMessagesReceivedQueueAnswer(qint64,qint32)));
    connect(mApi, SIGNAL(messagesReceivedQueueError(qint64,QString,QString)), this, SLOT(0nMessagesReceivedQueueError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesReadMessageContentsAnswer(qint64,QList<qint32>)), this, SLOT(onMessagesReadMessageContentsAnswer(qint64,QList<qint32>)));
    connect(mApi, SIGNAL(messagesReadMessageContentsError(qint64,QString,QString)), this, SLOT(0nMessagesReadMessageContentsError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesGetStickersAnswer(qint64,QString,QString)), this, SLOT(onMessagesGetStickersAnswer(qint64,QString,QString)));
    connect(mApi, SIGNAL(messagesGetStickersError(qint64,QString,QString)), this, SLOT(0nMessagesGetStickersError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesGetAllStickersAnswer(qint64,qint32)), this, SLOT(onMessagesGetAllStickersAnswer(qint64,qint32)));
    connect(mApi, SIGNAL(messagesGetAllStickersError(qint64,QString,QString)), this, SLOT(0nMessagesGetAllStickersError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesGetWebPagePreviewAnswer(qint64,QString)), this, SLOT(onMessagesGetWebPagePreviewAnswer(qint64,QString)));
    connect(mApi, SIGNAL(messagesGetWebPagePreviewError(qint64,QString,QString)), this, SLOT(0nMessagesGetWebPagePreviewError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesExportChatInviteAnswer(qint64,qint32)), this, SLOT(onMessagesExportChatInviteAnswer(qint64,qint32)));
    connect(mApi, SIGNAL(messagesExportChatInviteError(qint64,QString,QString)), this, SLOT(0nMessagesExportChatInviteError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesCheckChatInviteAnswer(qint64,QString)), this, SLOT(onMessagesCheckChatInviteAnswer(qint64,QString)));
    connect(mApi, SIGNAL(messagesCheckChatInviteError(qint64,QString,QString)), this, SLOT(0nMessagesCheckChatInviteError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesImportChatInviteAnswer(qint64,QString)), this, SLOT(onMessagesImportChatInviteAnswer(qint64,QString)));
    connect(mApi, SIGNAL(messagesImportChatInviteError(qint64,QString,QString)), this, SLOT(0nMessagesImportChatInviteError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesGetStickerSetAnswer(qint64,InputStickerSet)), this, SLOT(onMessagesGetStickerSetAnswer(qint64,InputStickerSet)));
    connect(mApi, SIGNAL(messagesGetStickerSetError(qint64,QString,QString)), this, SLOT(0nMessagesGetStickerSetError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesInstallStickerSetAnswer(qint64,InputStickerSet,bool)), this, SLOT(onMessagesInstallStickerSetAnswer(qint64,InputStickerSet,bool)));
    connect(mApi, SIGNAL(messagesInstallStickerSetError(qint64,QString,QString)), this, SLOT(0nMessagesInstallStickerSetError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesUninstallStickerSetAnswer(qint64,InputStickerSet)), this, SLOT(onMessagesUninstallStickerSetAnswer(qint64,InputStickerSet)));
    connect(mApi, SIGNAL(messagesUninstallStickerSetError(qint64,QString,QString)), this, SLOT(0nMessagesUninstallStickerSetError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesStartBotAnswer(qint64,InputUser,InputPeer,qint64,QString)), this, SLOT(onMessagesStartBotAnswer(qint64,InputUser,InputPeer,qint64,QString)));
    connect(mApi, SIGNAL(messagesStartBotError(qint64,QString,QString)), this, SLOT(0nMessagesStartBotError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesGetMessagesViewsAnswer(qint64,InputPeer,QList<qint32>,bool)), this, SLOT(onMessagesGetMessagesViewsAnswer(qint64,InputPeer,QList<qint32>,bool)));
    connect(mApi, SIGNAL(messagesGetMessagesViewsError(qint64,QString,QString)), this, SLOT(0nMessagesGetMessagesViewsError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesToggleChatAdminsAnswer(qint64,qint32,bool)), this, SLOT(onMessagesToggleChatAdminsAnswer(qint64,qint32,bool)));
    connect(mApi, SIGNAL(messagesToggleChatAdminsError(qint64,QString,QString)), this, SLOT(0nMessagesToggleChatAdminsError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesEditChatAdminAnswer(qint64,qint32,InputUser,bool)), this, SLOT(onMessagesEditChatAdminAnswer(qint64,qint32,InputUser,bool)));
    connect(mApi, SIGNAL(messagesEditChatAdminError(qint64,QString,QString)), this, SLOT(0nMessagesEditChatAdminError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesMigrateChatAnswer(qint64,qint32)), this, SLOT(onMessagesMigrateChatAnswer(qint64,qint32)));
    connect(mApi, SIGNAL(messagesMigrateChatError(qint64,QString,QString)), this, SLOT(0nMessagesMigrateChatError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesSearchGlobalAnswer(qint64,QString,qint32,InputPeer,qint32,qint32)), this, SLOT(onMessagesSearchGlobalAnswer(qint64,QString,qint32,InputPeer,qint32,qint32)));
    connect(mApi, SIGNAL(messagesSearchGlobalError(qint64,QString,QString)), this, SLOT(0nMessagesSearchGlobalError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesReorderStickerSetsAnswer(qint64,QList<qint64>)), this, SLOT(onMessagesReorderStickerSetsAnswer(qint64,QList<qint64>)));
    connect(mApi, SIGNAL(messagesReorderStickerSetsError(qint64,QString,QString)), this, SLOT(0nMessagesReorderStickerSetsError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesGetDocumentByHashAnswer(qint64,QByteArray,qint32,QString)), this, SLOT(onMessagesGetDocumentByHashAnswer(qint64,QByteArray,qint32,QString)));
    connect(mApi, SIGNAL(messagesGetDocumentByHashError(qint64,QString,QString)), this, SLOT(0nMessagesGetDocumentByHashError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesSearchGifsAnswer(qint64,QString,qint32)), this, SLOT(onMessagesSearchGifsAnswer(qint64,QString,qint32)));
    connect(mApi, SIGNAL(messagesSearchGifsError(qint64,QString,QString)), this, SLOT(0nMessagesSearchGifsError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesGetSavedGifsAnswer(qint64,qint32)), this, SLOT(onMessagesGetSavedGifsAnswer(qint64,qint32)));
    connect(mApi, SIGNAL(messagesGetSavedGifsError(qint64,QString,QString)), this, SLOT(0nMessagesGetSavedGifsError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesSaveGifAnswer(qint64,InputDocument,bool)), this, SLOT(onMessagesSaveGifAnswer(qint64,InputDocument,bool)));
    connect(mApi, SIGNAL(messagesSaveGifError(qint64,QString,QString)), this, SLOT(0nMessagesSaveGifError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesGetInlineBotResultsAnswer(qint64,InputUser,QString,QString)), this, SLOT(onMessagesGetInlineBotResultsAnswer(qint64,InputUser,QString,QString)));
    connect(mApi, SIGNAL(messagesGetInlineBotResultsError(qint64,QString,QString)), this, SLOT(0nMessagesGetInlineBotResultsError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesSetInlineBotResultsAnswer(qint64,bool,bool,qint64,QList<InputBotInlineResult>,qint32,QString)), this, SLOT(onMessagesSetInlineBotResultsAnswer(qint64,bool,bool,qint64,QList<InputBotInlineResult>,qint32,QString)));
    connect(mApi, SIGNAL(messagesSetInlineBotResultsError(qint64,QString,QString)), this, SLOT(0nMessagesSetInlineBotResultsError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(messagesSendInlineBotResultAnswer(qint64,bool,InputPeer,qint32,qint64,qint64,QString)), this, SLOT(onMessagesSendInlineBotResultAnswer(qint64,bool,InputPeer,qint32,qint64,qint64,QString)));
    connect(mApi, SIGNAL(messagesSendInlineBotResultError(qint64,QString,QString)), this, SLOT(0nMessagesSendInlineBotResultError(qint64,QString,QString)));
    
    
    connect(mApi, SIGNAL(photosUpdateProfilePhotoAnswer(qint64,InputPhoto,InputPhotoCrop)), this, SLOT(onPhotosUpdateProfilePhotoAnswer(qint64,InputPhoto,InputPhotoCrop)));
    connect(mApi, SIGNAL(photosUpdateProfilePhotoError(qint64,QString,QString)), this, SLOT(0nPhotosUpdateProfilePhotoError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(photosUploadProfilePhotoAnswer(qint64,InputFile,QString,InputGeoPoint,InputPhotoCrop)), this, SLOT(onPhotosUploadProfilePhotoAnswer(qint64,InputFile,QString,InputGeoPoint,InputPhotoCrop)));
    connect(mApi, SIGNAL(photosUploadProfilePhotoError(qint64,QString,QString)), this, SLOT(0nPhotosUploadProfilePhotoError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(photosDeletePhotosAnswer(qint64,QList<InputPhoto>)), this, SLOT(onPhotosDeletePhotosAnswer(qint64,QList<InputPhoto>)));
    connect(mApi, SIGNAL(photosDeletePhotosError(qint64,QString,QString)), this, SLOT(0nPhotosDeletePhotosError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(photosGetUserPhotosAnswer(qint64,InputUser,qint32,qint64,qint32)), this, SLOT(onPhotosGetUserPhotosAnswer(qint64,InputUser,qint32,qint64,qint32)));
    connect(mApi, SIGNAL(photosGetUserPhotosError(qint64,QString,QString)), this, SLOT(0nPhotosGetUserPhotosError(qint64,QString,QString)));
    
    
    connect(mApi, SIGNAL(updatesGetStateAnswer(qint64)), this, SLOT(onUpdatesGetStateAnswer(qint64)));
    connect(mApi, SIGNAL(updatesGetStateError(qint64,QString,QString)), this, SLOT(0nUpdatesGetStateError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(updatesGetDifferenceAnswer(qint64,qint32,qint32,qint32)), this, SLOT(onUpdatesGetDifferenceAnswer(qint64,qint32,qint32,qint32)));
    connect(mApi, SIGNAL(updatesGetDifferenceError(qint64,QString,QString)), this, SLOT(0nUpdatesGetDifferenceError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(updatesGetChannelDifferenceAnswer(qint64,InputChannel,ChannelMessagesFilter,qint32,qint32)), this, SLOT(onUpdatesGetChannelDifferenceAnswer(qint64,InputChannel,ChannelMessagesFilter,qint32,qint32)));
    connect(mApi, SIGNAL(updatesGetChannelDifferenceError(qint64,QString,QString)), this, SLOT(0nUpdatesGetChannelDifferenceError(qint64,QString,QString)));
    
    
    connect(mApi, SIGNAL(uploadSaveFilePartAnswer(qint64,qint64,qint32,QByteArray)), this, SLOT(onUploadSaveFilePartAnswer(qint64,qint64,qint32,QByteArray)));
    connect(mApi, SIGNAL(uploadSaveFilePartError(qint64,QString,QString)), this, SLOT(0nUploadSaveFilePartError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(uploadGetFileAnswer(qint64,InputFileLocation,qint32,qint32)), this, SLOT(onUploadGetFileAnswer(qint64,InputFileLocation,qint32,qint32)));
    connect(mApi, SIGNAL(uploadGetFileError(qint64,QString,QString)), this, SLOT(0nUploadGetFileError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(uploadSaveBigFilePartAnswer(qint64,qint64,qint32,qint32,QByteArray)), this, SLOT(onUploadSaveBigFilePartAnswer(qint64,qint64,qint32,qint32,QByteArray)));
    connect(mApi, SIGNAL(uploadSaveBigFilePartError(qint64,QString,QString)), this, SLOT(0nUploadSaveBigFilePartError(qint64,QString,QString)));
    
    
    connect(mApi, SIGNAL(usersGetUsersAnswer(qint64,QList<InputUser>)), this, SLOT(onUsersGetUsersAnswer(qint64,QList<InputUser>)));
    connect(mApi, SIGNAL(usersGetUsersError(qint64,QString,QString)), this, SLOT(0nUsersGetUsersError(qint64,QString,QString)));
    
    connect(mApi, SIGNAL(usersGetFullUserAnswer(qint64,InputUser)), this, SLOT(onUsersGetFullUserAnswer(qint64,InputUser)));
    connect(mApi, SIGNAL(usersGetFullUserError(qint64,QString,QString)), this, SLOT(0nUsersGetFullUserError(qint64,QString,QString)));

}

qint64 TelegramCore::accountRegisterDevice(qint32 token_type, const QString &token, const QString &device_model, const QString &system_version, const QString &app_version, bool app_sandbox, const QString &lang_code, Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountRegisterDevice(token_type, token, device_model, system_version, app_version, app_sandbox, lang_code);
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountRegisterDeviceAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT accountRegisterDeviceAnswer(msgId, result);
}

void TelegramCore::onAccountRegisterDeviceError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT accountRegisterDeviceError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountUnregisterDevice(qint32 token_type, const QString &token, Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountUnregisterDevice(token_type, token);
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountUnregisterDeviceAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT accountUnregisterDeviceAnswer(msgId, result);
}

void TelegramCore::onAccountUnregisterDeviceError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT accountUnregisterDeviceError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountUpdateNotifySettings(const InputNotifyPeer &peer, const InputPeerNotifySettings &settings, Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountUpdateNotifySettings(peer, settings);
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountUpdateNotifySettingsAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT accountUpdateNotifySettingsAnswer(msgId, result);
}

void TelegramCore::onAccountUpdateNotifySettingsError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT accountUpdateNotifySettingsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountGetNotifySettings(const InputNotifyPeer &peer, Callback<PeerNotifySettings > callBack) {
    if(!mApi) {
        const PeerNotifySettings &result = PeerNotifySettings();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountGetNotifySettings(peer);
    if(msgId)
        callBackPush<PeerNotifySettings >(msgId, callBack);
    else {
        const PeerNotifySettings &result = PeerNotifySettings();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountGetNotifySettingsAnswer(qint64 msgId, const PeerNotifySettings &result) {
    callBackCall<PeerNotifySettings >(msgId, result);
    Q_EMIT accountGetNotifySettingsAnswer(msgId, result);
}

void TelegramCore::onAccountGetNotifySettingsError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const PeerNotifySettings &result = PeerNotifySettings();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<PeerNotifySettings >(msgId, result, error);
    Q_EMIT accountGetNotifySettingsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountResetNotifySettings(Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountResetNotifySettings();
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountResetNotifySettingsAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT accountResetNotifySettingsAnswer(msgId, result);
}

void TelegramCore::onAccountResetNotifySettingsError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT accountResetNotifySettingsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountUpdateProfile(const QString &first_name, const QString &last_name, Callback<User > callBack) {
    if(!mApi) {
        const User &result = User();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountUpdateProfile(first_name, last_name);
    if(msgId)
        callBackPush<User >(msgId, callBack);
    else {
        const User &result = User();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountUpdateProfileAnswer(qint64 msgId, const User &result) {
    callBackCall<User >(msgId, result);
    Q_EMIT accountUpdateProfileAnswer(msgId, result);
}

void TelegramCore::onAccountUpdateProfileError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const User &result = User();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<User >(msgId, result, error);
    Q_EMIT accountUpdateProfileError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountUpdateStatus(bool offline, Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountUpdateStatus(offline);
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountUpdateStatusAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT accountUpdateStatusAnswer(msgId, result);
}

void TelegramCore::onAccountUpdateStatusError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT accountUpdateStatusError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountGetWallPapers(Callback<QList<WallPaper> > callBack) {
    if(!mApi) {
        const QList<WallPaper> &result = QList<WallPaper>();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountGetWallPapers();
    if(msgId)
        callBackPush<QList<WallPaper> >(msgId, callBack);
    else {
        const QList<WallPaper> &result = QList<WallPaper>();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountGetWallPapersAnswer(qint64 msgId, const QList<WallPaper> &result) {
    callBackCall<QList<WallPaper> >(msgId, result);
    Q_EMIT accountGetWallPapersAnswer(msgId, result);
}

void TelegramCore::onAccountGetWallPapersError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const QList<WallPaper> &result = QList<WallPaper>();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<QList<WallPaper> >(msgId, result, error);
    Q_EMIT accountGetWallPapersError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountReportPeer(const InputPeer &peer, const ReportReason &reason, Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountReportPeer(peer, reason);
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountReportPeerAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT accountReportPeerAnswer(msgId, result);
}

void TelegramCore::onAccountReportPeerError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT accountReportPeerError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountCheckUsername(const QString &username, Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountCheckUsername(username);
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountCheckUsernameAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT accountCheckUsernameAnswer(msgId, result);
}

void TelegramCore::onAccountCheckUsernameError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT accountCheckUsernameError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountUpdateUsername(const QString &username, Callback<User > callBack) {
    if(!mApi) {
        const User &result = User();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountUpdateUsername(username);
    if(msgId)
        callBackPush<User >(msgId, callBack);
    else {
        const User &result = User();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountUpdateUsernameAnswer(qint64 msgId, const User &result) {
    callBackCall<User >(msgId, result);
    Q_EMIT accountUpdateUsernameAnswer(msgId, result);
}

void TelegramCore::onAccountUpdateUsernameError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const User &result = User();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<User >(msgId, result, error);
    Q_EMIT accountUpdateUsernameError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountGetPrivacy(const InputPrivacyKey &key, Callback<AccountPrivacyRules > callBack) {
    if(!mApi) {
        const AccountPrivacyRules &result = AccountPrivacyRules();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountGetPrivacy(key);
    if(msgId)
        callBackPush<AccountPrivacyRules >(msgId, callBack);
    else {
        const AccountPrivacyRules &result = AccountPrivacyRules();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountGetPrivacyAnswer(qint64 msgId, const AccountPrivacyRules &result) {
    callBackCall<AccountPrivacyRules >(msgId, result);
    Q_EMIT accountGetPrivacyAnswer(msgId, result);
}

void TelegramCore::onAccountGetPrivacyError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const AccountPrivacyRules &result = AccountPrivacyRules();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AccountPrivacyRules >(msgId, result, error);
    Q_EMIT accountGetPrivacyError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountSetPrivacy(const InputPrivacyKey &key, const QList<InputPrivacyRule> &rules, Callback<AccountPrivacyRules > callBack) {
    if(!mApi) {
        const AccountPrivacyRules &result = AccountPrivacyRules();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountSetPrivacy(key, rules);
    if(msgId)
        callBackPush<AccountPrivacyRules >(msgId, callBack);
    else {
        const AccountPrivacyRules &result = AccountPrivacyRules();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountSetPrivacyAnswer(qint64 msgId, const AccountPrivacyRules &result) {
    callBackCall<AccountPrivacyRules >(msgId, result);
    Q_EMIT accountSetPrivacyAnswer(msgId, result);
}

void TelegramCore::onAccountSetPrivacyError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const AccountPrivacyRules &result = AccountPrivacyRules();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AccountPrivacyRules >(msgId, result, error);
    Q_EMIT accountSetPrivacyError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountDeleteAccount(const QString &reason, Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountDeleteAccount(reason);
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountDeleteAccountAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT accountDeleteAccountAnswer(msgId, result);
}

void TelegramCore::onAccountDeleteAccountError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT accountDeleteAccountError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountGetAccountTTL(Callback<AccountDaysTTL > callBack) {
    if(!mApi) {
        const AccountDaysTTL &result = AccountDaysTTL();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountGetAccountTTL();
    if(msgId)
        callBackPush<AccountDaysTTL >(msgId, callBack);
    else {
        const AccountDaysTTL &result = AccountDaysTTL();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountGetAccountTTLAnswer(qint64 msgId, const AccountDaysTTL &result) {
    callBackCall<AccountDaysTTL >(msgId, result);
    Q_EMIT accountGetAccountTTLAnswer(msgId, result);
}

void TelegramCore::onAccountGetAccountTTLError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const AccountDaysTTL &result = AccountDaysTTL();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AccountDaysTTL >(msgId, result, error);
    Q_EMIT accountGetAccountTTLError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountSetAccountTTL(const AccountDaysTTL &ttl, Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountSetAccountTTL(ttl);
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountSetAccountTTLAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT accountSetAccountTTLAnswer(msgId, result);
}

void TelegramCore::onAccountSetAccountTTLError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT accountSetAccountTTLError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountSendChangePhoneCode(const QString &phone_number, Callback<AccountSentChangePhoneCode > callBack) {
    if(!mApi) {
        const AccountSentChangePhoneCode &result = AccountSentChangePhoneCode();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountSendChangePhoneCode(phone_number);
    if(msgId)
        callBackPush<AccountSentChangePhoneCode >(msgId, callBack);
    else {
        const AccountSentChangePhoneCode &result = AccountSentChangePhoneCode();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountSendChangePhoneCodeAnswer(qint64 msgId, const AccountSentChangePhoneCode &result) {
    callBackCall<AccountSentChangePhoneCode >(msgId, result);
    Q_EMIT accountSendChangePhoneCodeAnswer(msgId, result);
}

void TelegramCore::onAccountSendChangePhoneCodeError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const AccountSentChangePhoneCode &result = AccountSentChangePhoneCode();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AccountSentChangePhoneCode >(msgId, result, error);
    Q_EMIT accountSendChangePhoneCodeError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountChangePhone(const QString &phone_number, const QString &phone_code_hash, const QString &phone_code, Callback<User > callBack) {
    if(!mApi) {
        const User &result = User();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountChangePhone(phone_number, phone_code_hash, phone_code);
    if(msgId)
        callBackPush<User >(msgId, callBack);
    else {
        const User &result = User();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountChangePhoneAnswer(qint64 msgId, const User &result) {
    callBackCall<User >(msgId, result);
    Q_EMIT accountChangePhoneAnswer(msgId, result);
}

void TelegramCore::onAccountChangePhoneError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const User &result = User();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<User >(msgId, result, error);
    Q_EMIT accountChangePhoneError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountUpdateDeviceLocked(qint32 period, Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountUpdateDeviceLocked(period);
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountUpdateDeviceLockedAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT accountUpdateDeviceLockedAnswer(msgId, result);
}

void TelegramCore::onAccountUpdateDeviceLockedError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT accountUpdateDeviceLockedError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountGetAuthorizations(Callback<AccountAuthorizations > callBack) {
    if(!mApi) {
        const AccountAuthorizations &result = AccountAuthorizations();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountGetAuthorizations();
    if(msgId)
        callBackPush<AccountAuthorizations >(msgId, callBack);
    else {
        const AccountAuthorizations &result = AccountAuthorizations();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountGetAuthorizationsAnswer(qint64 msgId, const AccountAuthorizations &result) {
    callBackCall<AccountAuthorizations >(msgId, result);
    Q_EMIT accountGetAuthorizationsAnswer(msgId, result);
}

void TelegramCore::onAccountGetAuthorizationsError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const AccountAuthorizations &result = AccountAuthorizations();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AccountAuthorizations >(msgId, result, error);
    Q_EMIT accountGetAuthorizationsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountResetAuthorization(qint64 hash, Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountResetAuthorization(hash);
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountResetAuthorizationAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT accountResetAuthorizationAnswer(msgId, result);
}

void TelegramCore::onAccountResetAuthorizationError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT accountResetAuthorizationError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountGetPassword(Callback<AccountPassword > callBack) {
    if(!mApi) {
        const AccountPassword &result = AccountPassword();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountGetPassword();
    if(msgId)
        callBackPush<AccountPassword >(msgId, callBack);
    else {
        const AccountPassword &result = AccountPassword();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountGetPasswordAnswer(qint64 msgId, const AccountPassword &result) {
    callBackCall<AccountPassword >(msgId, result);
    Q_EMIT accountGetPasswordAnswer(msgId, result);
}

void TelegramCore::onAccountGetPasswordError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const AccountPassword &result = AccountPassword();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AccountPassword >(msgId, result, error);
    Q_EMIT accountGetPasswordError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountGetPasswordSettings(const QByteArray &current_password_hash, Callback<AccountPasswordSettings > callBack) {
    if(!mApi) {
        const AccountPasswordSettings &result = AccountPasswordSettings();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountGetPasswordSettings(current_password_hash);
    if(msgId)
        callBackPush<AccountPasswordSettings >(msgId, callBack);
    else {
        const AccountPasswordSettings &result = AccountPasswordSettings();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountGetPasswordSettingsAnswer(qint64 msgId, const AccountPasswordSettings &result) {
    callBackCall<AccountPasswordSettings >(msgId, result);
    Q_EMIT accountGetPasswordSettingsAnswer(msgId, result);
}

void TelegramCore::onAccountGetPasswordSettingsError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const AccountPasswordSettings &result = AccountPasswordSettings();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AccountPasswordSettings >(msgId, result, error);
    Q_EMIT accountGetPasswordSettingsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountUpdatePasswordSettings(const QByteArray &current_password_hash, const AccountPasswordInputSettings &new_settings, Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountUpdatePasswordSettings(current_password_hash, new_settings);
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountUpdatePasswordSettingsAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT accountUpdatePasswordSettingsAnswer(msgId, result);
}

void TelegramCore::onAccountUpdatePasswordSettingsError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT accountUpdatePasswordSettingsError(msgId, errorCode, errorText);
}


qint64 TelegramCore::authCheckPhone(const QString &phone_number, Callback<AuthCheckedPhone > callBack) {
    if(!mApi) {
        const AuthCheckedPhone &result = AuthCheckedPhone();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authCheckPhone(phone_number);
    if(msgId)
        callBackPush<AuthCheckedPhone >(msgId, callBack);
    else {
        const AuthCheckedPhone &result = AuthCheckedPhone();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthCheckPhoneAnswer(qint64 msgId, const AuthCheckedPhone &result) {
    callBackCall<AuthCheckedPhone >(msgId, result);
    Q_EMIT authCheckPhoneAnswer(msgId, result);
}

void TelegramCore::onAuthCheckPhoneError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const AuthCheckedPhone &result = AuthCheckedPhone();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AuthCheckedPhone >(msgId, result, error);
    Q_EMIT authCheckPhoneError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authSendCode(const QString &phone_number, qint32 sms_type, qint32 api_id, const QString &api_hash, const QString &lang_code, Callback<AuthSentCode > callBack) {
    if(!mApi) {
        const AuthSentCode &result = AuthSentCode();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authSendCode(phone_number, sms_type, api_id, api_hash, lang_code);
    if(msgId)
        callBackPush<AuthSentCode >(msgId, callBack);
    else {
        const AuthSentCode &result = AuthSentCode();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthSendCodeAnswer(qint64 msgId, const AuthSentCode &result) {
    callBackCall<AuthSentCode >(msgId, result);
    Q_EMIT authSendCodeAnswer(msgId, result);
}

void TelegramCore::onAuthSendCodeError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const AuthSentCode &result = AuthSentCode();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AuthSentCode >(msgId, result, error);
    Q_EMIT authSendCodeError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authSendCall(const QString &phone_number, const QString &phone_code_hash, Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authSendCall(phone_number, phone_code_hash);
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthSendCallAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT authSendCallAnswer(msgId, result);
}

void TelegramCore::onAuthSendCallError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT authSendCallError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authSignUp(const QString &phone_number, const QString &phone_code_hash, const QString &phone_code, const QString &first_name, const QString &last_name, Callback<AuthAuthorization > callBack) {
    if(!mApi) {
        const AuthAuthorization &result = AuthAuthorization();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authSignUp(phone_number, phone_code_hash, phone_code, first_name, last_name);
    if(msgId)
        callBackPush<AuthAuthorization >(msgId, callBack);
    else {
        const AuthAuthorization &result = AuthAuthorization();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthSignUpAnswer(qint64 msgId, const AuthAuthorization &result) {
    callBackCall<AuthAuthorization >(msgId, result);
    Q_EMIT authSignUpAnswer(msgId, result);
}

void TelegramCore::onAuthSignUpError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const AuthAuthorization &result = AuthAuthorization();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AuthAuthorization >(msgId, result, error);
    Q_EMIT authSignUpError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authSignIn(const QString &phone_number, const QString &phone_code_hash, const QString &phone_code, Callback<AuthAuthorization > callBack) {
    if(!mApi) {
        const AuthAuthorization &result = AuthAuthorization();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authSignIn(phone_number, phone_code_hash, phone_code);
    if(msgId)
        callBackPush<AuthAuthorization >(msgId, callBack);
    else {
        const AuthAuthorization &result = AuthAuthorization();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthSignInAnswer(qint64 msgId, const AuthAuthorization &result) {
    callBackCall<AuthAuthorization >(msgId, result);
    Q_EMIT authSignInAnswer(msgId, result);
}

void TelegramCore::onAuthSignInError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const AuthAuthorization &result = AuthAuthorization();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AuthAuthorization >(msgId, result, error);
    Q_EMIT authSignInError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authLogOut(Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authLogOut();
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthLogOutAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT authLogOutAnswer(msgId, result);
}

void TelegramCore::onAuthLogOutError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT authLogOutError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authResetAuthorizations(Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authResetAuthorizations();
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthResetAuthorizationsAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT authResetAuthorizationsAnswer(msgId, result);
}

void TelegramCore::onAuthResetAuthorizationsError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT authResetAuthorizationsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authSendInvites(const QList<QString> &phone_numbers, const QString &message, Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authSendInvites(phone_numbers, message);
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthSendInvitesAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT authSendInvitesAnswer(msgId, result);
}

void TelegramCore::onAuthSendInvitesError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT authSendInvitesError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authExportAuthorization(qint32 dc_id, Callback<AuthExportedAuthorization > callBack) {
    if(!mApi) {
        const AuthExportedAuthorization &result = AuthExportedAuthorization();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authExportAuthorization(dc_id);
    if(msgId)
        callBackPush<AuthExportedAuthorization >(msgId, callBack);
    else {
        const AuthExportedAuthorization &result = AuthExportedAuthorization();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthExportAuthorizationAnswer(qint64 msgId, const AuthExportedAuthorization &result) {
    callBackCall<AuthExportedAuthorization >(msgId, result);
    Q_EMIT authExportAuthorizationAnswer(msgId, result);
}

void TelegramCore::onAuthExportAuthorizationError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const AuthExportedAuthorization &result = AuthExportedAuthorization();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AuthExportedAuthorization >(msgId, result, error);
    Q_EMIT authExportAuthorizationError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authImportAuthorization(qint32 id, const QByteArray &bytes, Callback<AuthAuthorization > callBack) {
    if(!mApi) {
        const AuthAuthorization &result = AuthAuthorization();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authImportAuthorization(id, bytes);
    if(msgId)
        callBackPush<AuthAuthorization >(msgId, callBack);
    else {
        const AuthAuthorization &result = AuthAuthorization();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthImportAuthorizationAnswer(qint64 msgId, const AuthAuthorization &result) {
    callBackCall<AuthAuthorization >(msgId, result);
    Q_EMIT authImportAuthorizationAnswer(msgId, result);
}

void TelegramCore::onAuthImportAuthorizationError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const AuthAuthorization &result = AuthAuthorization();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AuthAuthorization >(msgId, result, error);
    Q_EMIT authImportAuthorizationError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authBindTempAuthKey(qint64 perm_auth_key_id, qint64 nonce, qint32 expires_at, const QByteArray &encrypted_message, Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authBindTempAuthKey(perm_auth_key_id, nonce, expires_at, encrypted_message);
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthBindTempAuthKeyAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT authBindTempAuthKeyAnswer(msgId, result);
}

void TelegramCore::onAuthBindTempAuthKeyError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT authBindTempAuthKeyError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authSendSms(const QString &phone_number, const QString &phone_code_hash, Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authSendSms(phone_number, phone_code_hash);
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthSendSmsAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT authSendSmsAnswer(msgId, result);
}

void TelegramCore::onAuthSendSmsError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT authSendSmsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authImportBotAuthorization(qint32 flags, qint32 api_id, const QString &api_hash, const QString &bot_auth_token, Callback<AuthAuthorization > callBack) {
    if(!mApi) {
        const AuthAuthorization &result = AuthAuthorization();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authImportBotAuthorization(flags, api_id, api_hash, bot_auth_token);
    if(msgId)
        callBackPush<AuthAuthorization >(msgId, callBack);
    else {
        const AuthAuthorization &result = AuthAuthorization();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthImportBotAuthorizationAnswer(qint64 msgId, const AuthAuthorization &result) {
    callBackCall<AuthAuthorization >(msgId, result);
    Q_EMIT authImportBotAuthorizationAnswer(msgId, result);
}

void TelegramCore::onAuthImportBotAuthorizationError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const AuthAuthorization &result = AuthAuthorization();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AuthAuthorization >(msgId, result, error);
    Q_EMIT authImportBotAuthorizationError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authCheckPassword(const QByteArray &password_hash, Callback<AuthAuthorization > callBack) {
    if(!mApi) {
        const AuthAuthorization &result = AuthAuthorization();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authCheckPassword(password_hash);
    if(msgId)
        callBackPush<AuthAuthorization >(msgId, callBack);
    else {
        const AuthAuthorization &result = AuthAuthorization();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthCheckPasswordAnswer(qint64 msgId, const AuthAuthorization &result) {
    callBackCall<AuthAuthorization >(msgId, result);
    Q_EMIT authCheckPasswordAnswer(msgId, result);
}

void TelegramCore::onAuthCheckPasswordError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const AuthAuthorization &result = AuthAuthorization();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AuthAuthorization >(msgId, result, error);
    Q_EMIT authCheckPasswordError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authRequestPasswordRecovery(Callback<AuthPasswordRecovery > callBack) {
    if(!mApi) {
        const AuthPasswordRecovery &result = AuthPasswordRecovery();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authRequestPasswordRecovery();
    if(msgId)
        callBackPush<AuthPasswordRecovery >(msgId, callBack);
    else {
        const AuthPasswordRecovery &result = AuthPasswordRecovery();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthRequestPasswordRecoveryAnswer(qint64 msgId, const AuthPasswordRecovery &result) {
    callBackCall<AuthPasswordRecovery >(msgId, result);
    Q_EMIT authRequestPasswordRecoveryAnswer(msgId, result);
}

void TelegramCore::onAuthRequestPasswordRecoveryError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const AuthPasswordRecovery &result = AuthPasswordRecovery();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AuthPasswordRecovery >(msgId, result, error);
    Q_EMIT authRequestPasswordRecoveryError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authRecoverPassword(const QString &code, Callback<AuthAuthorization > callBack) {
    if(!mApi) {
        const AuthAuthorization &result = AuthAuthorization();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authRecoverPassword(code);
    if(msgId)
        callBackPush<AuthAuthorization >(msgId, callBack);
    else {
        const AuthAuthorization &result = AuthAuthorization();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthRecoverPasswordAnswer(qint64 msgId, const AuthAuthorization &result) {
    callBackCall<AuthAuthorization >(msgId, result);
    Q_EMIT authRecoverPasswordAnswer(msgId, result);
}

void TelegramCore::onAuthRecoverPasswordError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const AuthAuthorization &result = AuthAuthorization();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AuthAuthorization >(msgId, result, error);
    Q_EMIT authRecoverPasswordError(msgId, errorCode, errorText);
}


qint64 TelegramCore::channelsGetDialogs(qint32 offset, qint32 limit, Callback<MessagesDialogs > callBack) {
    if(!mApi) {
        const MessagesDialogs &result = MessagesDialogs();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsGetDialogs(offset, limit);
    if(msgId)
        callBackPush<MessagesDialogs >(msgId, callBack);
    else {
        const MessagesDialogs &result = MessagesDialogs();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsGetDialogsAnswer(qint64 msgId, const MessagesDialogs &result) {
    callBackCall<MessagesDialogs >(msgId, result);
    Q_EMIT channelsGetDialogsAnswer(msgId, result);
}

void TelegramCore::onChannelsGetDialogsError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const MessagesDialogs &result = MessagesDialogs();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesDialogs >(msgId, result, error);
    Q_EMIT channelsGetDialogsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsGetImportantHistory(const InputChannel &channel, qint32 offset_id, qint32 add_offset, qint32 limit, qint32 max_id, qint32 min_id, Callback<MessagesMessages > callBack) {
    if(!mApi) {
        const MessagesMessages &result = MessagesMessages();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsGetImportantHistory(channel, offset_id, add_offset, limit, max_id, min_id);
    if(msgId)
        callBackPush<MessagesMessages >(msgId, callBack);
    else {
        const MessagesMessages &result = MessagesMessages();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsGetImportantHistoryAnswer(qint64 msgId, const MessagesMessages &result) {
    callBackCall<MessagesMessages >(msgId, result);
    Q_EMIT channelsGetImportantHistoryAnswer(msgId, result);
}

void TelegramCore::onChannelsGetImportantHistoryError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const MessagesMessages &result = MessagesMessages();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesMessages >(msgId, result, error);
    Q_EMIT channelsGetImportantHistoryError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsReadHistory(const InputChannel &channel, qint32 max_id, Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsReadHistory(channel, max_id);
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsReadHistoryAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT channelsReadHistoryAnswer(msgId, result);
}

void TelegramCore::onChannelsReadHistoryError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT channelsReadHistoryError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsDeleteMessages(const InputChannel &channel, const QList<qint32> &id, Callback<MessagesAffectedMessages > callBack) {
    if(!mApi) {
        const MessagesAffectedMessages &result = MessagesAffectedMessages();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsDeleteMessages(channel, id);
    if(msgId)
        callBackPush<MessagesAffectedMessages >(msgId, callBack);
    else {
        const MessagesAffectedMessages &result = MessagesAffectedMessages();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsDeleteMessagesAnswer(qint64 msgId, const MessagesAffectedMessages &result) {
    callBackCall<MessagesAffectedMessages >(msgId, result);
    Q_EMIT channelsDeleteMessagesAnswer(msgId, result);
}

void TelegramCore::onChannelsDeleteMessagesError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const MessagesAffectedMessages &result = MessagesAffectedMessages();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesAffectedMessages >(msgId, result, error);
    Q_EMIT channelsDeleteMessagesError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsDeleteUserHistory(const InputChannel &channel, const InputUser &user_id, Callback<MessagesAffectedHistory > callBack) {
    if(!mApi) {
        const MessagesAffectedHistory &result = MessagesAffectedHistory();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsDeleteUserHistory(channel, user_id);
    if(msgId)
        callBackPush<MessagesAffectedHistory >(msgId, callBack);
    else {
        const MessagesAffectedHistory &result = MessagesAffectedHistory();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsDeleteUserHistoryAnswer(qint64 msgId, const MessagesAffectedHistory &result) {
    callBackCall<MessagesAffectedHistory >(msgId, result);
    Q_EMIT channelsDeleteUserHistoryAnswer(msgId, result);
}

void TelegramCore::onChannelsDeleteUserHistoryError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const MessagesAffectedHistory &result = MessagesAffectedHistory();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesAffectedHistory >(msgId, result, error);
    Q_EMIT channelsDeleteUserHistoryError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsReportSpam(const InputChannel &channel, const InputUser &user_id, const QList<qint32> &id, Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsReportSpam(channel, user_id, id);
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsReportSpamAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT channelsReportSpamAnswer(msgId, result);
}

void TelegramCore::onChannelsReportSpamError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT channelsReportSpamError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsGetMessages(const InputChannel &channel, const QList<qint32> &id, Callback<MessagesMessages > callBack) {
    if(!mApi) {
        const MessagesMessages &result = MessagesMessages();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsGetMessages(channel, id);
    if(msgId)
        callBackPush<MessagesMessages >(msgId, callBack);
    else {
        const MessagesMessages &result = MessagesMessages();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsGetMessagesAnswer(qint64 msgId, const MessagesMessages &result) {
    callBackCall<MessagesMessages >(msgId, result);
    Q_EMIT channelsGetMessagesAnswer(msgId, result);
}

void TelegramCore::onChannelsGetMessagesError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const MessagesMessages &result = MessagesMessages();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesMessages >(msgId, result, error);
    Q_EMIT channelsGetMessagesError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsGetParticipants(const InputChannel &channel, const ChannelParticipantsFilter &filter, qint32 offset, qint32 limit, Callback<ChannelsChannelParticipants > callBack) {
    if(!mApi) {
        const ChannelsChannelParticipants &result = ChannelsChannelParticipants();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsGetParticipants(channel, filter, offset, limit);
    if(msgId)
        callBackPush<ChannelsChannelParticipants >(msgId, callBack);
    else {
        const ChannelsChannelParticipants &result = ChannelsChannelParticipants();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsGetParticipantsAnswer(qint64 msgId, const ChannelsChannelParticipants &result) {
    callBackCall<ChannelsChannelParticipants >(msgId, result);
    Q_EMIT channelsGetParticipantsAnswer(msgId, result);
}

void TelegramCore::onChannelsGetParticipantsError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const ChannelsChannelParticipants &result = ChannelsChannelParticipants();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<ChannelsChannelParticipants >(msgId, result, error);
    Q_EMIT channelsGetParticipantsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsGetParticipant(const InputChannel &channel, const InputUser &user_id, Callback<ChannelsChannelParticipant > callBack) {
    if(!mApi) {
        const ChannelsChannelParticipant &result = ChannelsChannelParticipant();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsGetParticipant(channel, user_id);
    if(msgId)
        callBackPush<ChannelsChannelParticipant >(msgId, callBack);
    else {
        const ChannelsChannelParticipant &result = ChannelsChannelParticipant();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsGetParticipantAnswer(qint64 msgId, const ChannelsChannelParticipant &result) {
    callBackCall<ChannelsChannelParticipant >(msgId, result);
    Q_EMIT channelsGetParticipantAnswer(msgId, result);
}

void TelegramCore::onChannelsGetParticipantError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const ChannelsChannelParticipant &result = ChannelsChannelParticipant();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<ChannelsChannelParticipant >(msgId, result, error);
    Q_EMIT channelsGetParticipantError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsGetChannels(const QList<InputChannel> &id, Callback<MessagesChats > callBack) {
    if(!mApi) {
        const MessagesChats &result = MessagesChats();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsGetChannels(id);
    if(msgId)
        callBackPush<MessagesChats >(msgId, callBack);
    else {
        const MessagesChats &result = MessagesChats();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsGetChannelsAnswer(qint64 msgId, const MessagesChats &result) {
    callBackCall<MessagesChats >(msgId, result);
    Q_EMIT channelsGetChannelsAnswer(msgId, result);
}

void TelegramCore::onChannelsGetChannelsError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const MessagesChats &result = MessagesChats();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesChats >(msgId, result, error);
    Q_EMIT channelsGetChannelsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsGetFullChannel(const InputChannel &channel, Callback<MessagesChatFull > callBack) {
    if(!mApi) {
        const MessagesChatFull &result = MessagesChatFull();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsGetFullChannel(channel);
    if(msgId)
        callBackPush<MessagesChatFull >(msgId, callBack);
    else {
        const MessagesChatFull &result = MessagesChatFull();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsGetFullChannelAnswer(qint64 msgId, const MessagesChatFull &result) {
    callBackCall<MessagesChatFull >(msgId, result);
    Q_EMIT channelsGetFullChannelAnswer(msgId, result);
}

void TelegramCore::onChannelsGetFullChannelError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const MessagesChatFull &result = MessagesChatFull();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesChatFull >(msgId, result, error);
    Q_EMIT channelsGetFullChannelError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsCreateChannel(bool broadcast, bool megagroup, const QString &title, const QString &about, Callback<UpdatesType > callBack) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsCreateChannel(broadcast, megagroup, title, about);
    if(msgId)
        callBackPush<UpdatesType >(msgId, callBack);
    else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsCreateChannelAnswer(qint64 msgId, const UpdatesType &result) {
    callBackCall<UpdatesType >(msgId, result);
    Q_EMIT channelsCreateChannelAnswer(msgId, result);
}

void TelegramCore::onChannelsCreateChannelError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    Q_EMIT channelsCreateChannelError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsEditAbout(const InputChannel &channel, const QString &about, Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsEditAbout(channel, about);
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsEditAboutAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT channelsEditAboutAnswer(msgId, result);
}

void TelegramCore::onChannelsEditAboutError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT channelsEditAboutError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsEditAdmin(const InputChannel &channel, const InputUser &user_id, const ChannelParticipantRole &role, Callback<UpdatesType > callBack) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsEditAdmin(channel, user_id, role);
    if(msgId)
        callBackPush<UpdatesType >(msgId, callBack);
    else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsEditAdminAnswer(qint64 msgId, const UpdatesType &result) {
    callBackCall<UpdatesType >(msgId, result);
    Q_EMIT channelsEditAdminAnswer(msgId, result);
}

void TelegramCore::onChannelsEditAdminError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    Q_EMIT channelsEditAdminError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsEditTitle(const InputChannel &channel, const QString &title, Callback<UpdatesType > callBack) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsEditTitle(channel, title);
    if(msgId)
        callBackPush<UpdatesType >(msgId, callBack);
    else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsEditTitleAnswer(qint64 msgId, const UpdatesType &result) {
    callBackCall<UpdatesType >(msgId, result);
    Q_EMIT channelsEditTitleAnswer(msgId, result);
}

void TelegramCore::onChannelsEditTitleError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    Q_EMIT channelsEditTitleError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsEditPhoto(const InputChannel &channel, const InputChatPhoto &photo, Callback<UpdatesType > callBack) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsEditPhoto(channel, photo);
    if(msgId)
        callBackPush<UpdatesType >(msgId, callBack);
    else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsEditPhotoAnswer(qint64 msgId, const UpdatesType &result) {
    callBackCall<UpdatesType >(msgId, result);
    Q_EMIT channelsEditPhotoAnswer(msgId, result);
}

void TelegramCore::onChannelsEditPhotoError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    Q_EMIT channelsEditPhotoError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsToggleComments(const InputChannel &channel, bool enabled, Callback<UpdatesType > callBack) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsToggleComments(channel, enabled);
    if(msgId)
        callBackPush<UpdatesType >(msgId, callBack);
    else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsToggleCommentsAnswer(qint64 msgId, const UpdatesType &result) {
    callBackCall<UpdatesType >(msgId, result);
    Q_EMIT channelsToggleCommentsAnswer(msgId, result);
}

void TelegramCore::onChannelsToggleCommentsError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    Q_EMIT channelsToggleCommentsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsCheckUsername(const InputChannel &channel, const QString &username, Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsCheckUsername(channel, username);
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsCheckUsernameAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT channelsCheckUsernameAnswer(msgId, result);
}

void TelegramCore::onChannelsCheckUsernameError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT channelsCheckUsernameError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsUpdateUsername(const InputChannel &channel, const QString &username, Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsUpdateUsername(channel, username);
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsUpdateUsernameAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT channelsUpdateUsernameAnswer(msgId, result);
}

void TelegramCore::onChannelsUpdateUsernameError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT channelsUpdateUsernameError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsJoinChannel(const InputChannel &channel, Callback<UpdatesType > callBack) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsJoinChannel(channel);
    if(msgId)
        callBackPush<UpdatesType >(msgId, callBack);
    else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsJoinChannelAnswer(qint64 msgId, const UpdatesType &result) {
    callBackCall<UpdatesType >(msgId, result);
    Q_EMIT channelsJoinChannelAnswer(msgId, result);
}

void TelegramCore::onChannelsJoinChannelError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    Q_EMIT channelsJoinChannelError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsLeaveChannel(const InputChannel &channel, Callback<UpdatesType > callBack) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsLeaveChannel(channel);
    if(msgId)
        callBackPush<UpdatesType >(msgId, callBack);
    else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsLeaveChannelAnswer(qint64 msgId, const UpdatesType &result) {
    callBackCall<UpdatesType >(msgId, result);
    Q_EMIT channelsLeaveChannelAnswer(msgId, result);
}

void TelegramCore::onChannelsLeaveChannelError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    Q_EMIT channelsLeaveChannelError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsInviteToChannel(const InputChannel &channel, const QList<InputUser> &users, Callback<UpdatesType > callBack) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsInviteToChannel(channel, users);
    if(msgId)
        callBackPush<UpdatesType >(msgId, callBack);
    else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsInviteToChannelAnswer(qint64 msgId, const UpdatesType &result) {
    callBackCall<UpdatesType >(msgId, result);
    Q_EMIT channelsInviteToChannelAnswer(msgId, result);
}

void TelegramCore::onChannelsInviteToChannelError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    Q_EMIT channelsInviteToChannelError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsKickFromChannel(const InputChannel &channel, const InputUser &user_id, bool kicked, Callback<UpdatesType > callBack) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsKickFromChannel(channel, user_id, kicked);
    if(msgId)
        callBackPush<UpdatesType >(msgId, callBack);
    else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsKickFromChannelAnswer(qint64 msgId, const UpdatesType &result) {
    callBackCall<UpdatesType >(msgId, result);
    Q_EMIT channelsKickFromChannelAnswer(msgId, result);
}

void TelegramCore::onChannelsKickFromChannelError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    Q_EMIT channelsKickFromChannelError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsExportInvite(const InputChannel &channel, Callback<ExportedChatInvite > callBack) {
    if(!mApi) {
        const ExportedChatInvite &result = ExportedChatInvite();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsExportInvite(channel);
    if(msgId)
        callBackPush<ExportedChatInvite >(msgId, callBack);
    else {
        const ExportedChatInvite &result = ExportedChatInvite();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsExportInviteAnswer(qint64 msgId, const ExportedChatInvite &result) {
    callBackCall<ExportedChatInvite >(msgId, result);
    Q_EMIT channelsExportInviteAnswer(msgId, result);
}

void TelegramCore::onChannelsExportInviteError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const ExportedChatInvite &result = ExportedChatInvite();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<ExportedChatInvite >(msgId, result, error);
    Q_EMIT channelsExportInviteError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsDeleteChannel(const InputChannel &channel, Callback<UpdatesType > callBack) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsDeleteChannel(channel);
    if(msgId)
        callBackPush<UpdatesType >(msgId, callBack);
    else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsDeleteChannelAnswer(qint64 msgId, const UpdatesType &result) {
    callBackCall<UpdatesType >(msgId, result);
    Q_EMIT channelsDeleteChannelAnswer(msgId, result);
}

void TelegramCore::onChannelsDeleteChannelError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    Q_EMIT channelsDeleteChannelError(msgId, errorCode, errorText);
}


qint64 TelegramCore::contactsGetStatuses(Callback<QList<ContactStatus> > callBack) {
    if(!mApi) {
        const QList<ContactStatus> &result = QList<ContactStatus>();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsGetStatuses();
    if(msgId)
        callBackPush<QList<ContactStatus> >(msgId, callBack);
    else {
        const QList<ContactStatus> &result = QList<ContactStatus>();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsGetStatusesAnswer(qint64 msgId, const QList<ContactStatus> &result) {
    callBackCall<QList<ContactStatus> >(msgId, result);
    Q_EMIT contactsGetStatusesAnswer(msgId, result);
}

void TelegramCore::onContactsGetStatusesError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const QList<ContactStatus> &result = QList<ContactStatus>();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<QList<ContactStatus> >(msgId, result, error);
    Q_EMIT contactsGetStatusesError(msgId, errorCode, errorText);
}

qint64 TelegramCore::contactsGetContacts(const QString &hash, Callback<ContactsContacts > callBack) {
    if(!mApi) {
        const ContactsContacts &result = ContactsContacts();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsGetContacts(hash);
    if(msgId)
        callBackPush<ContactsContacts >(msgId, callBack);
    else {
        const ContactsContacts &result = ContactsContacts();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsGetContactsAnswer(qint64 msgId, const ContactsContacts &result) {
    callBackCall<ContactsContacts >(msgId, result);
    Q_EMIT contactsGetContactsAnswer(msgId, result);
}

void TelegramCore::onContactsGetContactsError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const ContactsContacts &result = ContactsContacts();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<ContactsContacts >(msgId, result, error);
    Q_EMIT contactsGetContactsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::contactsImportContacts(const QList<InputContact> &contacts, bool replace, Callback<ContactsImportedContacts > callBack) {
    if(!mApi) {
        const ContactsImportedContacts &result = ContactsImportedContacts();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsImportContacts(contacts, replace);
    if(msgId)
        callBackPush<ContactsImportedContacts >(msgId, callBack);
    else {
        const ContactsImportedContacts &result = ContactsImportedContacts();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsImportContactsAnswer(qint64 msgId, const ContactsImportedContacts &result) {
    callBackCall<ContactsImportedContacts >(msgId, result);
    Q_EMIT contactsImportContactsAnswer(msgId, result);
}

void TelegramCore::onContactsImportContactsError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const ContactsImportedContacts &result = ContactsImportedContacts();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<ContactsImportedContacts >(msgId, result, error);
    Q_EMIT contactsImportContactsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::contactsGetSuggested(qint32 limit, Callback<ContactsSuggested > callBack) {
    if(!mApi) {
        const ContactsSuggested &result = ContactsSuggested();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsGetSuggested(limit);
    if(msgId)
        callBackPush<ContactsSuggested >(msgId, callBack);
    else {
        const ContactsSuggested &result = ContactsSuggested();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsGetSuggestedAnswer(qint64 msgId, const ContactsSuggested &result) {
    callBackCall<ContactsSuggested >(msgId, result);
    Q_EMIT contactsGetSuggestedAnswer(msgId, result);
}

void TelegramCore::onContactsGetSuggestedError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const ContactsSuggested &result = ContactsSuggested();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<ContactsSuggested >(msgId, result, error);
    Q_EMIT contactsGetSuggestedError(msgId, errorCode, errorText);
}

qint64 TelegramCore::contactsDeleteContact(const InputUser &id, Callback<ContactsLink > callBack) {
    if(!mApi) {
        const ContactsLink &result = ContactsLink();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsDeleteContact(id);
    if(msgId)
        callBackPush<ContactsLink >(msgId, callBack);
    else {
        const ContactsLink &result = ContactsLink();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsDeleteContactAnswer(qint64 msgId, const ContactsLink &result) {
    callBackCall<ContactsLink >(msgId, result);
    Q_EMIT contactsDeleteContactAnswer(msgId, result);
}

void TelegramCore::onContactsDeleteContactError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const ContactsLink &result = ContactsLink();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<ContactsLink >(msgId, result, error);
    Q_EMIT contactsDeleteContactError(msgId, errorCode, errorText);
}

qint64 TelegramCore::contactsDeleteContacts(const QList<InputUser> &id, Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsDeleteContacts(id);
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsDeleteContactsAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT contactsDeleteContactsAnswer(msgId, result);
}

void TelegramCore::onContactsDeleteContactsError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT contactsDeleteContactsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::contactsBlock(const InputUser &id, Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsBlock(id);
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsBlockAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT contactsBlockAnswer(msgId, result);
}

void TelegramCore::onContactsBlockError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT contactsBlockError(msgId, errorCode, errorText);
}

qint64 TelegramCore::contactsUnblock(const InputUser &id, Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsUnblock(id);
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsUnblockAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT contactsUnblockAnswer(msgId, result);
}

void TelegramCore::onContactsUnblockError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT contactsUnblockError(msgId, errorCode, errorText);
}

qint64 TelegramCore::contactsGetBlocked(qint32 offset, qint32 limit, Callback<ContactsBlocked > callBack) {
    if(!mApi) {
        const ContactsBlocked &result = ContactsBlocked();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsGetBlocked(offset, limit);
    if(msgId)
        callBackPush<ContactsBlocked >(msgId, callBack);
    else {
        const ContactsBlocked &result = ContactsBlocked();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsGetBlockedAnswer(qint64 msgId, const ContactsBlocked &result) {
    callBackCall<ContactsBlocked >(msgId, result);
    Q_EMIT contactsGetBlockedAnswer(msgId, result);
}

void TelegramCore::onContactsGetBlockedError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const ContactsBlocked &result = ContactsBlocked();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<ContactsBlocked >(msgId, result, error);
    Q_EMIT contactsGetBlockedError(msgId, errorCode, errorText);
}

qint64 TelegramCore::contactsExportCard(Callback<QList<qint32> > callBack) {
    if(!mApi) {
        const QList<qint32> &result = QList<qint32>();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsExportCard();
    if(msgId)
        callBackPush<QList<qint32> >(msgId, callBack);
    else {
        const QList<qint32> &result = QList<qint32>();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsExportCardAnswer(qint64 msgId, const QList<qint32> &result) {
    callBackCall<QList<qint32> >(msgId, result);
    Q_EMIT contactsExportCardAnswer(msgId, result);
}

void TelegramCore::onContactsExportCardError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const QList<qint32> &result = QList<qint32>();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<QList<qint32> >(msgId, result, error);
    Q_EMIT contactsExportCardError(msgId, errorCode, errorText);
}

qint64 TelegramCore::contactsImportCard(const QList<qint32> &export_card, Callback<User > callBack) {
    if(!mApi) {
        const User &result = User();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsImportCard(export_card);
    if(msgId)
        callBackPush<User >(msgId, callBack);
    else {
        const User &result = User();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsImportCardAnswer(qint64 msgId, const User &result) {
    callBackCall<User >(msgId, result);
    Q_EMIT contactsImportCardAnswer(msgId, result);
}

void TelegramCore::onContactsImportCardError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const User &result = User();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<User >(msgId, result, error);
    Q_EMIT contactsImportCardError(msgId, errorCode, errorText);
}

qint64 TelegramCore::contactsSearch(const QString &q, qint32 limit, Callback<ContactsFound > callBack) {
    if(!mApi) {
        const ContactsFound &result = ContactsFound();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsSearch(q, limit);
    if(msgId)
        callBackPush<ContactsFound >(msgId, callBack);
    else {
        const ContactsFound &result = ContactsFound();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsSearchAnswer(qint64 msgId, const ContactsFound &result) {
    callBackCall<ContactsFound >(msgId, result);
    Q_EMIT contactsSearchAnswer(msgId, result);
}

void TelegramCore::onContactsSearchError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const ContactsFound &result = ContactsFound();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<ContactsFound >(msgId, result, error);
    Q_EMIT contactsSearchError(msgId, errorCode, errorText);
}

qint64 TelegramCore::contactsResolveUsername(const QString &username, Callback<ContactsResolvedPeer > callBack) {
    if(!mApi) {
        const ContactsResolvedPeer &result = ContactsResolvedPeer();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsResolveUsername(username);
    if(msgId)
        callBackPush<ContactsResolvedPeer >(msgId, callBack);
    else {
        const ContactsResolvedPeer &result = ContactsResolvedPeer();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsResolveUsernameAnswer(qint64 msgId, const ContactsResolvedPeer &result) {
    callBackCall<ContactsResolvedPeer >(msgId, result);
    Q_EMIT contactsResolveUsernameAnswer(msgId, result);
}

void TelegramCore::onContactsResolveUsernameError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const ContactsResolvedPeer &result = ContactsResolvedPeer();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<ContactsResolvedPeer >(msgId, result, error);
    Q_EMIT contactsResolveUsernameError(msgId, errorCode, errorText);
}


qint64 TelegramCore::helpGetConfig(Callback<Config > callBack) {
    if(!mApi) {
        const Config &result = Config();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->helpGetConfig();
    if(msgId)
        callBackPush<Config >(msgId, callBack);
    else {
        const Config &result = Config();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onHelpGetConfigAnswer(qint64 msgId, const Config &result) {
    callBackCall<Config >(msgId, result);
    Q_EMIT helpGetConfigAnswer(msgId, result);
}

void TelegramCore::onHelpGetConfigError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const Config &result = Config();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<Config >(msgId, result, error);
    Q_EMIT helpGetConfigError(msgId, errorCode, errorText);
}

qint64 TelegramCore::helpGetNearestDc(Callback<NearestDc > callBack) {
    if(!mApi) {
        const NearestDc &result = NearestDc();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->helpGetNearestDc();
    if(msgId)
        callBackPush<NearestDc >(msgId, callBack);
    else {
        const NearestDc &result = NearestDc();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onHelpGetNearestDcAnswer(qint64 msgId, const NearestDc &result) {
    callBackCall<NearestDc >(msgId, result);
    Q_EMIT helpGetNearestDcAnswer(msgId, result);
}

void TelegramCore::onHelpGetNearestDcError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const NearestDc &result = NearestDc();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<NearestDc >(msgId, result, error);
    Q_EMIT helpGetNearestDcError(msgId, errorCode, errorText);
}

qint64 TelegramCore::helpGetAppUpdate(const QString &device_model, const QString &system_version, const QString &app_version, const QString &lang_code, Callback<HelpAppUpdate > callBack) {
    if(!mApi) {
        const HelpAppUpdate &result = HelpAppUpdate();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->helpGetAppUpdate(device_model, system_version, app_version, lang_code);
    if(msgId)
        callBackPush<HelpAppUpdate >(msgId, callBack);
    else {
        const HelpAppUpdate &result = HelpAppUpdate();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onHelpGetAppUpdateAnswer(qint64 msgId, const HelpAppUpdate &result) {
    callBackCall<HelpAppUpdate >(msgId, result);
    Q_EMIT helpGetAppUpdateAnswer(msgId, result);
}

void TelegramCore::onHelpGetAppUpdateError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const HelpAppUpdate &result = HelpAppUpdate();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<HelpAppUpdate >(msgId, result, error);
    Q_EMIT helpGetAppUpdateError(msgId, errorCode, errorText);
}

qint64 TelegramCore::helpSaveAppLog(const QList<InputAppEvent> &events, Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->helpSaveAppLog(events);
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onHelpSaveAppLogAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT helpSaveAppLogAnswer(msgId, result);
}

void TelegramCore::onHelpSaveAppLogError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT helpSaveAppLogError(msgId, errorCode, errorText);
}

qint64 TelegramCore::helpGetInviteText(const QString &lang_code, Callback<HelpInviteText > callBack) {
    if(!mApi) {
        const HelpInviteText &result = HelpInviteText();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->helpGetInviteText(lang_code);
    if(msgId)
        callBackPush<HelpInviteText >(msgId, callBack);
    else {
        const HelpInviteText &result = HelpInviteText();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onHelpGetInviteTextAnswer(qint64 msgId, const HelpInviteText &result) {
    callBackCall<HelpInviteText >(msgId, result);
    Q_EMIT helpGetInviteTextAnswer(msgId, result);
}

void TelegramCore::onHelpGetInviteTextError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const HelpInviteText &result = HelpInviteText();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<HelpInviteText >(msgId, result, error);
    Q_EMIT helpGetInviteTextError(msgId, errorCode, errorText);
}

qint64 TelegramCore::helpGetSupport(Callback<HelpSupport > callBack) {
    if(!mApi) {
        const HelpSupport &result = HelpSupport();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->helpGetSupport();
    if(msgId)
        callBackPush<HelpSupport >(msgId, callBack);
    else {
        const HelpSupport &result = HelpSupport();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onHelpGetSupportAnswer(qint64 msgId, const HelpSupport &result) {
    callBackCall<HelpSupport >(msgId, result);
    Q_EMIT helpGetSupportAnswer(msgId, result);
}

void TelegramCore::onHelpGetSupportError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const HelpSupport &result = HelpSupport();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<HelpSupport >(msgId, result, error);
    Q_EMIT helpGetSupportError(msgId, errorCode, errorText);
}

qint64 TelegramCore::helpGetAppChangelog(const QString &device_model, const QString &system_version, const QString &app_version, const QString &lang_code, Callback<HelpAppChangelog > callBack) {
    if(!mApi) {
        const HelpAppChangelog &result = HelpAppChangelog();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->helpGetAppChangelog(device_model, system_version, app_version, lang_code);
    if(msgId)
        callBackPush<HelpAppChangelog >(msgId, callBack);
    else {
        const HelpAppChangelog &result = HelpAppChangelog();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onHelpGetAppChangelogAnswer(qint64 msgId, const HelpAppChangelog &result) {
    callBackCall<HelpAppChangelog >(msgId, result);
    Q_EMIT helpGetAppChangelogAnswer(msgId, result);
}

void TelegramCore::onHelpGetAppChangelogError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const HelpAppChangelog &result = HelpAppChangelog();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<HelpAppChangelog >(msgId, result, error);
    Q_EMIT helpGetAppChangelogError(msgId, errorCode, errorText);
}

qint64 TelegramCore::helpGetTermsOfService(const QString &lang_code, Callback<HelpTermsOfService > callBack) {
    if(!mApi) {
        const HelpTermsOfService &result = HelpTermsOfService();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->helpGetTermsOfService(lang_code);
    if(msgId)
        callBackPush<HelpTermsOfService >(msgId, callBack);
    else {
        const HelpTermsOfService &result = HelpTermsOfService();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onHelpGetTermsOfServiceAnswer(qint64 msgId, const HelpTermsOfService &result) {
    callBackCall<HelpTermsOfService >(msgId, result);
    Q_EMIT helpGetTermsOfServiceAnswer(msgId, result);
}

void TelegramCore::onHelpGetTermsOfServiceError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const HelpTermsOfService &result = HelpTermsOfService();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<HelpTermsOfService >(msgId, result, error);
    Q_EMIT helpGetTermsOfServiceError(msgId, errorCode, errorText);
}


qint64 TelegramCore::messagesGetMessages(const QList<qint32> &id, Callback<MessagesMessages > callBack) {
    if(!mApi) {
        const MessagesMessages &result = MessagesMessages();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesGetMessages(id);
    if(msgId)
        callBackPush<MessagesMessages >(msgId, callBack);
    else {
        const MessagesMessages &result = MessagesMessages();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesGetMessagesAnswer(qint64 msgId, const MessagesMessages &result) {
    callBackCall<MessagesMessages >(msgId, result);
    Q_EMIT messagesGetMessagesAnswer(msgId, result);
}

void TelegramCore::onMessagesGetMessagesError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const MessagesMessages &result = MessagesMessages();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesMessages >(msgId, result, error);
    Q_EMIT messagesGetMessagesError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesGetDialogs(qint32 offset_date, qint32 offset_id, const InputPeer &offset_peer, qint32 limit, Callback<MessagesDialogs > callBack) {
    if(!mApi) {
        const MessagesDialogs &result = MessagesDialogs();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesGetDialogs(offset_date, offset_id, offset_peer, limit);
    if(msgId)
        callBackPush<MessagesDialogs >(msgId, callBack);
    else {
        const MessagesDialogs &result = MessagesDialogs();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesGetDialogsAnswer(qint64 msgId, const MessagesDialogs &result) {
    callBackCall<MessagesDialogs >(msgId, result);
    Q_EMIT messagesGetDialogsAnswer(msgId, result);
}

void TelegramCore::onMessagesGetDialogsError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const MessagesDialogs &result = MessagesDialogs();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesDialogs >(msgId, result, error);
    Q_EMIT messagesGetDialogsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesGetHistory(const InputPeer &peer, qint32 offset_id, qint32 add_offset, qint32 limit, qint32 max_id, qint32 min_id, Callback<MessagesMessages > callBack) {
    if(!mApi) {
        const MessagesMessages &result = MessagesMessages();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesGetHistory(peer, offset_id, add_offset, limit, max_id, min_id);
    if(msgId)
        callBackPush<MessagesMessages >(msgId, callBack);
    else {
        const MessagesMessages &result = MessagesMessages();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesGetHistoryAnswer(qint64 msgId, const MessagesMessages &result) {
    callBackCall<MessagesMessages >(msgId, result);
    Q_EMIT messagesGetHistoryAnswer(msgId, result);
}

void TelegramCore::onMessagesGetHistoryError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const MessagesMessages &result = MessagesMessages();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesMessages >(msgId, result, error);
    Q_EMIT messagesGetHistoryError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesSearch(bool important_only, const InputPeer &peer, const QString &q, const MessagesFilter &filter, qint32 min_date, qint32 max_date, qint32 offset, qint32 max_id, qint32 limit, Callback<MessagesMessages > callBack) {
    if(!mApi) {
        const MessagesMessages &result = MessagesMessages();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesSearch(important_only, peer, q, filter, min_date, max_date, offset, max_id, limit);
    if(msgId)
        callBackPush<MessagesMessages >(msgId, callBack);
    else {
        const MessagesMessages &result = MessagesMessages();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesSearchAnswer(qint64 msgId, const MessagesMessages &result) {
    callBackCall<MessagesMessages >(msgId, result);
    Q_EMIT messagesSearchAnswer(msgId, result);
}

void TelegramCore::onMessagesSearchError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const MessagesMessages &result = MessagesMessages();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesMessages >(msgId, result, error);
    Q_EMIT messagesSearchError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesReadHistory(const InputPeer &peer, qint32 max_id, Callback<MessagesAffectedMessages > callBack) {
    if(!mApi) {
        const MessagesAffectedMessages &result = MessagesAffectedMessages();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesReadHistory(peer, max_id);
    if(msgId)
        callBackPush<MessagesAffectedMessages >(msgId, callBack);
    else {
        const MessagesAffectedMessages &result = MessagesAffectedMessages();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesReadHistoryAnswer(qint64 msgId, const MessagesAffectedMessages &result) {
    callBackCall<MessagesAffectedMessages >(msgId, result);
    Q_EMIT messagesReadHistoryAnswer(msgId, result);
}

void TelegramCore::onMessagesReadHistoryError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const MessagesAffectedMessages &result = MessagesAffectedMessages();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesAffectedMessages >(msgId, result, error);
    Q_EMIT messagesReadHistoryError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesDeleteHistory(const InputPeer &peer, qint32 max_id, Callback<MessagesAffectedHistory > callBack) {
    if(!mApi) {
        const MessagesAffectedHistory &result = MessagesAffectedHistory();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesDeleteHistory(peer, max_id);
    if(msgId)
        callBackPush<MessagesAffectedHistory >(msgId, callBack);
    else {
        const MessagesAffectedHistory &result = MessagesAffectedHistory();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesDeleteHistoryAnswer(qint64 msgId, const MessagesAffectedHistory &result) {
    callBackCall<MessagesAffectedHistory >(msgId, result);
    Q_EMIT messagesDeleteHistoryAnswer(msgId, result);
}

void TelegramCore::onMessagesDeleteHistoryError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const MessagesAffectedHistory &result = MessagesAffectedHistory();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesAffectedHistory >(msgId, result, error);
    Q_EMIT messagesDeleteHistoryError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesDeleteMessages(const QList<qint32> &id, Callback<MessagesAffectedMessages > callBack) {
    if(!mApi) {
        const MessagesAffectedMessages &result = MessagesAffectedMessages();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesDeleteMessages(id);
    if(msgId)
        callBackPush<MessagesAffectedMessages >(msgId, callBack);
    else {
        const MessagesAffectedMessages &result = MessagesAffectedMessages();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesDeleteMessagesAnswer(qint64 msgId, const MessagesAffectedMessages &result) {
    callBackCall<MessagesAffectedMessages >(msgId, result);
    Q_EMIT messagesDeleteMessagesAnswer(msgId, result);
}

void TelegramCore::onMessagesDeleteMessagesError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const MessagesAffectedMessages &result = MessagesAffectedMessages();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesAffectedMessages >(msgId, result, error);
    Q_EMIT messagesDeleteMessagesError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesReceivedMessages(qint32 max_id, Callback<QList<ReceivedNotifyMessage> > callBack) {
    if(!mApi) {
        const QList<ReceivedNotifyMessage> &result = QList<ReceivedNotifyMessage>();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesReceivedMessages(max_id);
    if(msgId)
        callBackPush<QList<ReceivedNotifyMessage> >(msgId, callBack);
    else {
        const QList<ReceivedNotifyMessage> &result = QList<ReceivedNotifyMessage>();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesReceivedMessagesAnswer(qint64 msgId, const QList<ReceivedNotifyMessage> &result) {
    callBackCall<QList<ReceivedNotifyMessage> >(msgId, result);
    Q_EMIT messagesReceivedMessagesAnswer(msgId, result);
}

void TelegramCore::onMessagesReceivedMessagesError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const QList<ReceivedNotifyMessage> &result = QList<ReceivedNotifyMessage>();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<QList<ReceivedNotifyMessage> >(msgId, result, error);
    Q_EMIT messagesReceivedMessagesError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesSetTyping(const InputPeer &peer, const SendMessageAction &action, Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesSetTyping(peer, action);
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesSetTypingAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT messagesSetTypingAnswer(msgId, result);
}

void TelegramCore::onMessagesSetTypingError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT messagesSetTypingError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesSendMessage(bool no_webpage, bool broadcast, const InputPeer &peer, qint32 reply_to_msg_id, const QString &message, qint64 random_id, const ReplyMarkup &reply_markup, const QList<MessageEntity> &entities, Callback<UpdatesType > callBack) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesSendMessage(no_webpage, broadcast, peer, reply_to_msg_id, message, random_id, reply_markup, entities);
    if(msgId)
        callBackPush<UpdatesType >(msgId, callBack);
    else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesSendMessageAnswer(qint64 msgId, const UpdatesType &result) {
    callBackCall<UpdatesType >(msgId, result);
    Q_EMIT messagesSendMessageAnswer(msgId, result);
}

void TelegramCore::onMessagesSendMessageError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    Q_EMIT messagesSendMessageError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesSendMedia(bool broadcast, const InputPeer &peer, qint32 reply_to_msg_id, const InputMedia &media, qint64 random_id, const ReplyMarkup &reply_markup, Callback<UpdatesType > callBack) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesSendMedia(broadcast, peer, reply_to_msg_id, media, random_id, reply_markup);
    if(msgId)
        callBackPush<UpdatesType >(msgId, callBack);
    else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesSendMediaAnswer(qint64 msgId, const UpdatesType &result) {
    callBackCall<UpdatesType >(msgId, result);
    Q_EMIT messagesSendMediaAnswer(msgId, result);
}

void TelegramCore::onMessagesSendMediaError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    Q_EMIT messagesSendMediaError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesForwardMessages(bool broadcast, const InputPeer &from_peer, const QList<qint32> &id, const QList<qint64> &random_id, const InputPeer &to_peer, Callback<UpdatesType > callBack) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesForwardMessages(broadcast, from_peer, id, random_id, to_peer);
    if(msgId)
        callBackPush<UpdatesType >(msgId, callBack);
    else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesForwardMessagesAnswer(qint64 msgId, const UpdatesType &result) {
    callBackCall<UpdatesType >(msgId, result);
    Q_EMIT messagesForwardMessagesAnswer(msgId, result);
}

void TelegramCore::onMessagesForwardMessagesError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    Q_EMIT messagesForwardMessagesError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesReportSpam(const InputPeer &peer, Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesReportSpam(peer);
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesReportSpamAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT messagesReportSpamAnswer(msgId, result);
}

void TelegramCore::onMessagesReportSpamError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT messagesReportSpamError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesGetChats(const QList<qint32> &id, Callback<MessagesChats > callBack) {
    if(!mApi) {
        const MessagesChats &result = MessagesChats();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesGetChats(id);
    if(msgId)
        callBackPush<MessagesChats >(msgId, callBack);
    else {
        const MessagesChats &result = MessagesChats();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesGetChatsAnswer(qint64 msgId, const MessagesChats &result) {
    callBackCall<MessagesChats >(msgId, result);
    Q_EMIT messagesGetChatsAnswer(msgId, result);
}

void TelegramCore::onMessagesGetChatsError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const MessagesChats &result = MessagesChats();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesChats >(msgId, result, error);
    Q_EMIT messagesGetChatsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesGetFullChat(qint32 chat_id, Callback<MessagesChatFull > callBack) {
    if(!mApi) {
        const MessagesChatFull &result = MessagesChatFull();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesGetFullChat(chat_id);
    if(msgId)
        callBackPush<MessagesChatFull >(msgId, callBack);
    else {
        const MessagesChatFull &result = MessagesChatFull();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesGetFullChatAnswer(qint64 msgId, const MessagesChatFull &result) {
    callBackCall<MessagesChatFull >(msgId, result);
    Q_EMIT messagesGetFullChatAnswer(msgId, result);
}

void TelegramCore::onMessagesGetFullChatError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const MessagesChatFull &result = MessagesChatFull();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesChatFull >(msgId, result, error);
    Q_EMIT messagesGetFullChatError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesEditChatTitle(qint32 chat_id, const QString &title, Callback<UpdatesType > callBack) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesEditChatTitle(chat_id, title);
    if(msgId)
        callBackPush<UpdatesType >(msgId, callBack);
    else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesEditChatTitleAnswer(qint64 msgId, const UpdatesType &result) {
    callBackCall<UpdatesType >(msgId, result);
    Q_EMIT messagesEditChatTitleAnswer(msgId, result);
}

void TelegramCore::onMessagesEditChatTitleError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    Q_EMIT messagesEditChatTitleError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesEditChatPhoto(qint32 chat_id, const InputChatPhoto &photo, Callback<UpdatesType > callBack) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesEditChatPhoto(chat_id, photo);
    if(msgId)
        callBackPush<UpdatesType >(msgId, callBack);
    else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesEditChatPhotoAnswer(qint64 msgId, const UpdatesType &result) {
    callBackCall<UpdatesType >(msgId, result);
    Q_EMIT messagesEditChatPhotoAnswer(msgId, result);
}

void TelegramCore::onMessagesEditChatPhotoError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    Q_EMIT messagesEditChatPhotoError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesAddChatUser(qint32 chat_id, const InputUser &user_id, qint32 fwd_limit, Callback<UpdatesType > callBack) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesAddChatUser(chat_id, user_id, fwd_limit);
    if(msgId)
        callBackPush<UpdatesType >(msgId, callBack);
    else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesAddChatUserAnswer(qint64 msgId, const UpdatesType &result) {
    callBackCall<UpdatesType >(msgId, result);
    Q_EMIT messagesAddChatUserAnswer(msgId, result);
}

void TelegramCore::onMessagesAddChatUserError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    Q_EMIT messagesAddChatUserError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesDeleteChatUser(qint32 chat_id, const InputUser &user_id, Callback<UpdatesType > callBack) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesDeleteChatUser(chat_id, user_id);
    if(msgId)
        callBackPush<UpdatesType >(msgId, callBack);
    else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesDeleteChatUserAnswer(qint64 msgId, const UpdatesType &result) {
    callBackCall<UpdatesType >(msgId, result);
    Q_EMIT messagesDeleteChatUserAnswer(msgId, result);
}

void TelegramCore::onMessagesDeleteChatUserError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    Q_EMIT messagesDeleteChatUserError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesCreateChat(const QList<InputUser> &users, const QString &title, Callback<UpdatesType > callBack) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesCreateChat(users, title);
    if(msgId)
        callBackPush<UpdatesType >(msgId, callBack);
    else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesCreateChatAnswer(qint64 msgId, const UpdatesType &result) {
    callBackCall<UpdatesType >(msgId, result);
    Q_EMIT messagesCreateChatAnswer(msgId, result);
}

void TelegramCore::onMessagesCreateChatError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    Q_EMIT messagesCreateChatError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesForwardMessage(const InputPeer &peer, qint32 id, qint64 random_id, Callback<UpdatesType > callBack) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesForwardMessage(peer, id, random_id);
    if(msgId)
        callBackPush<UpdatesType >(msgId, callBack);
    else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesForwardMessageAnswer(qint64 msgId, const UpdatesType &result) {
    callBackCall<UpdatesType >(msgId, result);
    Q_EMIT messagesForwardMessageAnswer(msgId, result);
}

void TelegramCore::onMessagesForwardMessageError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    Q_EMIT messagesForwardMessageError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesSendBroadcast(const QList<InputUser> &contacts, const QList<qint64> &random_id, const QString &message, const InputMedia &media, Callback<UpdatesType > callBack) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesSendBroadcast(contacts, random_id, message, media);
    if(msgId)
        callBackPush<UpdatesType >(msgId, callBack);
    else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesSendBroadcastAnswer(qint64 msgId, const UpdatesType &result) {
    callBackCall<UpdatesType >(msgId, result);
    Q_EMIT messagesSendBroadcastAnswer(msgId, result);
}

void TelegramCore::onMessagesSendBroadcastError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    Q_EMIT messagesSendBroadcastError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesGetDhConfig(qint32 version, qint32 random_length, Callback<MessagesDhConfig > callBack) {
    if(!mApi) {
        const MessagesDhConfig &result = MessagesDhConfig();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesGetDhConfig(version, random_length);
    if(msgId)
        callBackPush<MessagesDhConfig >(msgId, callBack);
    else {
        const MessagesDhConfig &result = MessagesDhConfig();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesGetDhConfigAnswer(qint64 msgId, const MessagesDhConfig &result) {
    callBackCall<MessagesDhConfig >(msgId, result);
    Q_EMIT messagesGetDhConfigAnswer(msgId, result);
}

void TelegramCore::onMessagesGetDhConfigError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const MessagesDhConfig &result = MessagesDhConfig();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesDhConfig >(msgId, result, error);
    Q_EMIT messagesGetDhConfigError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesRequestEncryption(const InputUser &user_id, qint32 random_id, const QByteArray &g_a, Callback<EncryptedChat > callBack) {
    if(!mApi) {
        const EncryptedChat &result = EncryptedChat();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesRequestEncryption(user_id, random_id, g_a);
    if(msgId)
        callBackPush<EncryptedChat >(msgId, callBack);
    else {
        const EncryptedChat &result = EncryptedChat();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesRequestEncryptionAnswer(qint64 msgId, const EncryptedChat &result) {
    callBackCall<EncryptedChat >(msgId, result);
    Q_EMIT messagesRequestEncryptionAnswer(msgId, result);
}

void TelegramCore::onMessagesRequestEncryptionError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const EncryptedChat &result = EncryptedChat();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<EncryptedChat >(msgId, result, error);
    Q_EMIT messagesRequestEncryptionError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesAcceptEncryption(const InputEncryptedChat &peer, const QByteArray &g_b, qint64 key_fingerprint, Callback<EncryptedChat > callBack) {
    if(!mApi) {
        const EncryptedChat &result = EncryptedChat();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesAcceptEncryption(peer, g_b, key_fingerprint);
    if(msgId)
        callBackPush<EncryptedChat >(msgId, callBack);
    else {
        const EncryptedChat &result = EncryptedChat();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesAcceptEncryptionAnswer(qint64 msgId, const EncryptedChat &result) {
    callBackCall<EncryptedChat >(msgId, result);
    Q_EMIT messagesAcceptEncryptionAnswer(msgId, result);
}

void TelegramCore::onMessagesAcceptEncryptionError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const EncryptedChat &result = EncryptedChat();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<EncryptedChat >(msgId, result, error);
    Q_EMIT messagesAcceptEncryptionError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesDiscardEncryption(qint32 chat_id, Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesDiscardEncryption(chat_id);
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesDiscardEncryptionAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT messagesDiscardEncryptionAnswer(msgId, result);
}

void TelegramCore::onMessagesDiscardEncryptionError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT messagesDiscardEncryptionError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesSetEncryptedTyping(const InputEncryptedChat &peer, bool typing, Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesSetEncryptedTyping(peer, typing);
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesSetEncryptedTypingAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT messagesSetEncryptedTypingAnswer(msgId, result);
}

void TelegramCore::onMessagesSetEncryptedTypingError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT messagesSetEncryptedTypingError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesReadEncryptedHistory(const InputEncryptedChat &peer, qint32 max_date, Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesReadEncryptedHistory(peer, max_date);
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesReadEncryptedHistoryAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT messagesReadEncryptedHistoryAnswer(msgId, result);
}

void TelegramCore::onMessagesReadEncryptedHistoryError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT messagesReadEncryptedHistoryError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesSendEncrypted(const InputEncryptedChat &peer, qint64 random_id, const QByteArray &data, Callback<MessagesSentEncryptedMessage > callBack) {
    if(!mApi) {
        const MessagesSentEncryptedMessage &result = MessagesSentEncryptedMessage();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesSendEncrypted(peer, random_id, data);
    if(msgId)
        callBackPush<MessagesSentEncryptedMessage >(msgId, callBack);
    else {
        const MessagesSentEncryptedMessage &result = MessagesSentEncryptedMessage();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesSendEncryptedAnswer(qint64 msgId, const MessagesSentEncryptedMessage &result) {
    callBackCall<MessagesSentEncryptedMessage >(msgId, result);
    Q_EMIT messagesSendEncryptedAnswer(msgId, result);
}

void TelegramCore::onMessagesSendEncryptedError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const MessagesSentEncryptedMessage &result = MessagesSentEncryptedMessage();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesSentEncryptedMessage >(msgId, result, error);
    Q_EMIT messagesSendEncryptedError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesSendEncryptedFile(const InputEncryptedChat &peer, qint64 random_id, const QByteArray &data, const InputEncryptedFile &file, Callback<MessagesSentEncryptedMessage > callBack) {
    if(!mApi) {
        const MessagesSentEncryptedMessage &result = MessagesSentEncryptedMessage();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesSendEncryptedFile(peer, random_id, data, file);
    if(msgId)
        callBackPush<MessagesSentEncryptedMessage >(msgId, callBack);
    else {
        const MessagesSentEncryptedMessage &result = MessagesSentEncryptedMessage();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesSendEncryptedFileAnswer(qint64 msgId, const MessagesSentEncryptedMessage &result) {
    callBackCall<MessagesSentEncryptedMessage >(msgId, result);
    Q_EMIT messagesSendEncryptedFileAnswer(msgId, result);
}

void TelegramCore::onMessagesSendEncryptedFileError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const MessagesSentEncryptedMessage &result = MessagesSentEncryptedMessage();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesSentEncryptedMessage >(msgId, result, error);
    Q_EMIT messagesSendEncryptedFileError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesSendEncryptedService(const InputEncryptedChat &peer, qint64 random_id, const QByteArray &data, Callback<MessagesSentEncryptedMessage > callBack) {
    if(!mApi) {
        const MessagesSentEncryptedMessage &result = MessagesSentEncryptedMessage();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesSendEncryptedService(peer, random_id, data);
    if(msgId)
        callBackPush<MessagesSentEncryptedMessage >(msgId, callBack);
    else {
        const MessagesSentEncryptedMessage &result = MessagesSentEncryptedMessage();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesSendEncryptedServiceAnswer(qint64 msgId, const MessagesSentEncryptedMessage &result) {
    callBackCall<MessagesSentEncryptedMessage >(msgId, result);
    Q_EMIT messagesSendEncryptedServiceAnswer(msgId, result);
}

void TelegramCore::onMessagesSendEncryptedServiceError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const MessagesSentEncryptedMessage &result = MessagesSentEncryptedMessage();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesSentEncryptedMessage >(msgId, result, error);
    Q_EMIT messagesSendEncryptedServiceError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesReceivedQueue(qint32 max_qts, Callback<QList<qint64> > callBack) {
    if(!mApi) {
        const QList<qint64> &result = QList<qint64>();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesReceivedQueue(max_qts);
    if(msgId)
        callBackPush<QList<qint64> >(msgId, callBack);
    else {
        const QList<qint64> &result = QList<qint64>();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesReceivedQueueAnswer(qint64 msgId, const QList<qint64> &result) {
    callBackCall<QList<qint64> >(msgId, result);
    Q_EMIT messagesReceivedQueueAnswer(msgId, result);
}

void TelegramCore::onMessagesReceivedQueueError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const QList<qint64> &result = QList<qint64>();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<QList<qint64> >(msgId, result, error);
    Q_EMIT messagesReceivedQueueError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesReadMessageContents(const QList<qint32> &id, Callback<MessagesAffectedMessages > callBack) {
    if(!mApi) {
        const MessagesAffectedMessages &result = MessagesAffectedMessages();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesReadMessageContents(id);
    if(msgId)
        callBackPush<MessagesAffectedMessages >(msgId, callBack);
    else {
        const MessagesAffectedMessages &result = MessagesAffectedMessages();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesReadMessageContentsAnswer(qint64 msgId, const MessagesAffectedMessages &result) {
    callBackCall<MessagesAffectedMessages >(msgId, result);
    Q_EMIT messagesReadMessageContentsAnswer(msgId, result);
}

void TelegramCore::onMessagesReadMessageContentsError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const MessagesAffectedMessages &result = MessagesAffectedMessages();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesAffectedMessages >(msgId, result, error);
    Q_EMIT messagesReadMessageContentsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesGetStickers(const QString &emoticon, const QString &hash, Callback<MessagesStickers > callBack) {
    if(!mApi) {
        const MessagesStickers &result = MessagesStickers();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesGetStickers(emoticon, hash);
    if(msgId)
        callBackPush<MessagesStickers >(msgId, callBack);
    else {
        const MessagesStickers &result = MessagesStickers();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesGetStickersAnswer(qint64 msgId, const MessagesStickers &result) {
    callBackCall<MessagesStickers >(msgId, result);
    Q_EMIT messagesGetStickersAnswer(msgId, result);
}

void TelegramCore::onMessagesGetStickersError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const MessagesStickers &result = MessagesStickers();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesStickers >(msgId, result, error);
    Q_EMIT messagesGetStickersError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesGetAllStickers(qint32 hash, Callback<MessagesAllStickers > callBack) {
    if(!mApi) {
        const MessagesAllStickers &result = MessagesAllStickers();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesGetAllStickers(hash);
    if(msgId)
        callBackPush<MessagesAllStickers >(msgId, callBack);
    else {
        const MessagesAllStickers &result = MessagesAllStickers();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesGetAllStickersAnswer(qint64 msgId, const MessagesAllStickers &result) {
    callBackCall<MessagesAllStickers >(msgId, result);
    Q_EMIT messagesGetAllStickersAnswer(msgId, result);
}

void TelegramCore::onMessagesGetAllStickersError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const MessagesAllStickers &result = MessagesAllStickers();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesAllStickers >(msgId, result, error);
    Q_EMIT messagesGetAllStickersError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesGetWebPagePreview(const QString &message, Callback<MessageMedia > callBack) {
    if(!mApi) {
        const MessageMedia &result = MessageMedia();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesGetWebPagePreview(message);
    if(msgId)
        callBackPush<MessageMedia >(msgId, callBack);
    else {
        const MessageMedia &result = MessageMedia();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesGetWebPagePreviewAnswer(qint64 msgId, const MessageMedia &result) {
    callBackCall<MessageMedia >(msgId, result);
    Q_EMIT messagesGetWebPagePreviewAnswer(msgId, result);
}

void TelegramCore::onMessagesGetWebPagePreviewError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const MessageMedia &result = MessageMedia();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessageMedia >(msgId, result, error);
    Q_EMIT messagesGetWebPagePreviewError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesExportChatInvite(qint32 chat_id, Callback<ExportedChatInvite > callBack) {
    if(!mApi) {
        const ExportedChatInvite &result = ExportedChatInvite();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesExportChatInvite(chat_id);
    if(msgId)
        callBackPush<ExportedChatInvite >(msgId, callBack);
    else {
        const ExportedChatInvite &result = ExportedChatInvite();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesExportChatInviteAnswer(qint64 msgId, const ExportedChatInvite &result) {
    callBackCall<ExportedChatInvite >(msgId, result);
    Q_EMIT messagesExportChatInviteAnswer(msgId, result);
}

void TelegramCore::onMessagesExportChatInviteError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const ExportedChatInvite &result = ExportedChatInvite();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<ExportedChatInvite >(msgId, result, error);
    Q_EMIT messagesExportChatInviteError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesCheckChatInvite(const QString &hash, Callback<ChatInvite > callBack) {
    if(!mApi) {
        const ChatInvite &result = ChatInvite();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesCheckChatInvite(hash);
    if(msgId)
        callBackPush<ChatInvite >(msgId, callBack);
    else {
        const ChatInvite &result = ChatInvite();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesCheckChatInviteAnswer(qint64 msgId, const ChatInvite &result) {
    callBackCall<ChatInvite >(msgId, result);
    Q_EMIT messagesCheckChatInviteAnswer(msgId, result);
}

void TelegramCore::onMessagesCheckChatInviteError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const ChatInvite &result = ChatInvite();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<ChatInvite >(msgId, result, error);
    Q_EMIT messagesCheckChatInviteError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesImportChatInvite(const QString &hash, Callback<UpdatesType > callBack) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesImportChatInvite(hash);
    if(msgId)
        callBackPush<UpdatesType >(msgId, callBack);
    else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesImportChatInviteAnswer(qint64 msgId, const UpdatesType &result) {
    callBackCall<UpdatesType >(msgId, result);
    Q_EMIT messagesImportChatInviteAnswer(msgId, result);
}

void TelegramCore::onMessagesImportChatInviteError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    Q_EMIT messagesImportChatInviteError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesGetStickerSet(const InputStickerSet &stickerset, Callback<MessagesStickerSet > callBack) {
    if(!mApi) {
        const MessagesStickerSet &result = MessagesStickerSet();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesGetStickerSet(stickerset);
    if(msgId)
        callBackPush<MessagesStickerSet >(msgId, callBack);
    else {
        const MessagesStickerSet &result = MessagesStickerSet();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesGetStickerSetAnswer(qint64 msgId, const MessagesStickerSet &result) {
    callBackCall<MessagesStickerSet >(msgId, result);
    Q_EMIT messagesGetStickerSetAnswer(msgId, result);
}

void TelegramCore::onMessagesGetStickerSetError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const MessagesStickerSet &result = MessagesStickerSet();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesStickerSet >(msgId, result, error);
    Q_EMIT messagesGetStickerSetError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesInstallStickerSet(const InputStickerSet &stickerset, bool disabled, Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesInstallStickerSet(stickerset, disabled);
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesInstallStickerSetAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT messagesInstallStickerSetAnswer(msgId, result);
}

void TelegramCore::onMessagesInstallStickerSetError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT messagesInstallStickerSetError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesUninstallStickerSet(const InputStickerSet &stickerset, Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesUninstallStickerSet(stickerset);
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesUninstallStickerSetAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT messagesUninstallStickerSetAnswer(msgId, result);
}

void TelegramCore::onMessagesUninstallStickerSetError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT messagesUninstallStickerSetError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesStartBot(const InputUser &bot, const InputPeer &peer, qint64 random_id, const QString &start_param, Callback<UpdatesType > callBack) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesStartBot(bot, peer, random_id, start_param);
    if(msgId)
        callBackPush<UpdatesType >(msgId, callBack);
    else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesStartBotAnswer(qint64 msgId, const UpdatesType &result) {
    callBackCall<UpdatesType >(msgId, result);
    Q_EMIT messagesStartBotAnswer(msgId, result);
}

void TelegramCore::onMessagesStartBotError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    Q_EMIT messagesStartBotError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesGetMessagesViews(const InputPeer &peer, const QList<qint32> &id, bool increment, Callback<QList<qint32> > callBack) {
    if(!mApi) {
        const QList<qint32> &result = QList<qint32>();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesGetMessagesViews(peer, id, increment);
    if(msgId)
        callBackPush<QList<qint32> >(msgId, callBack);
    else {
        const QList<qint32> &result = QList<qint32>();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesGetMessagesViewsAnswer(qint64 msgId, const QList<qint32> &result) {
    callBackCall<QList<qint32> >(msgId, result);
    Q_EMIT messagesGetMessagesViewsAnswer(msgId, result);
}

void TelegramCore::onMessagesGetMessagesViewsError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const QList<qint32> &result = QList<qint32>();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<QList<qint32> >(msgId, result, error);
    Q_EMIT messagesGetMessagesViewsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesToggleChatAdmins(qint32 chat_id, bool enabled, Callback<UpdatesType > callBack) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesToggleChatAdmins(chat_id, enabled);
    if(msgId)
        callBackPush<UpdatesType >(msgId, callBack);
    else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesToggleChatAdminsAnswer(qint64 msgId, const UpdatesType &result) {
    callBackCall<UpdatesType >(msgId, result);
    Q_EMIT messagesToggleChatAdminsAnswer(msgId, result);
}

void TelegramCore::onMessagesToggleChatAdminsError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    Q_EMIT messagesToggleChatAdminsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesEditChatAdmin(qint32 chat_id, const InputUser &user_id, bool is_admin, Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesEditChatAdmin(chat_id, user_id, is_admin);
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesEditChatAdminAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT messagesEditChatAdminAnswer(msgId, result);
}

void TelegramCore::onMessagesEditChatAdminError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT messagesEditChatAdminError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesMigrateChat(qint32 chat_id, Callback<UpdatesType > callBack) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesMigrateChat(chat_id);
    if(msgId)
        callBackPush<UpdatesType >(msgId, callBack);
    else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesMigrateChatAnswer(qint64 msgId, const UpdatesType &result) {
    callBackCall<UpdatesType >(msgId, result);
    Q_EMIT messagesMigrateChatAnswer(msgId, result);
}

void TelegramCore::onMessagesMigrateChatError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    Q_EMIT messagesMigrateChatError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesSearchGlobal(const QString &q, qint32 offset_date, const InputPeer &offset_peer, qint32 offset_id, qint32 limit, Callback<MessagesMessages > callBack) {
    if(!mApi) {
        const MessagesMessages &result = MessagesMessages();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesSearchGlobal(q, offset_date, offset_peer, offset_id, limit);
    if(msgId)
        callBackPush<MessagesMessages >(msgId, callBack);
    else {
        const MessagesMessages &result = MessagesMessages();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesSearchGlobalAnswer(qint64 msgId, const MessagesMessages &result) {
    callBackCall<MessagesMessages >(msgId, result);
    Q_EMIT messagesSearchGlobalAnswer(msgId, result);
}

void TelegramCore::onMessagesSearchGlobalError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const MessagesMessages &result = MessagesMessages();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesMessages >(msgId, result, error);
    Q_EMIT messagesSearchGlobalError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesReorderStickerSets(const QList<qint64> &order, Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesReorderStickerSets(order);
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesReorderStickerSetsAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT messagesReorderStickerSetsAnswer(msgId, result);
}

void TelegramCore::onMessagesReorderStickerSetsError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT messagesReorderStickerSetsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesGetDocumentByHash(const QByteArray &sha256, qint32 size, const QString &mime_type, Callback<Document > callBack) {
    if(!mApi) {
        const Document &result = Document();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesGetDocumentByHash(sha256, size, mime_type);
    if(msgId)
        callBackPush<Document >(msgId, callBack);
    else {
        const Document &result = Document();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesGetDocumentByHashAnswer(qint64 msgId, const Document &result) {
    callBackCall<Document >(msgId, result);
    Q_EMIT messagesGetDocumentByHashAnswer(msgId, result);
}

void TelegramCore::onMessagesGetDocumentByHashError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const Document &result = Document();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<Document >(msgId, result, error);
    Q_EMIT messagesGetDocumentByHashError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesSearchGifs(const QString &q, qint32 offset, Callback<MessagesFoundGifs > callBack) {
    if(!mApi) {
        const MessagesFoundGifs &result = MessagesFoundGifs();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesSearchGifs(q, offset);
    if(msgId)
        callBackPush<MessagesFoundGifs >(msgId, callBack);
    else {
        const MessagesFoundGifs &result = MessagesFoundGifs();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesSearchGifsAnswer(qint64 msgId, const MessagesFoundGifs &result) {
    callBackCall<MessagesFoundGifs >(msgId, result);
    Q_EMIT messagesSearchGifsAnswer(msgId, result);
}

void TelegramCore::onMessagesSearchGifsError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const MessagesFoundGifs &result = MessagesFoundGifs();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesFoundGifs >(msgId, result, error);
    Q_EMIT messagesSearchGifsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesGetSavedGifs(qint32 hash, Callback<MessagesSavedGifs > callBack) {
    if(!mApi) {
        const MessagesSavedGifs &result = MessagesSavedGifs();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesGetSavedGifs(hash);
    if(msgId)
        callBackPush<MessagesSavedGifs >(msgId, callBack);
    else {
        const MessagesSavedGifs &result = MessagesSavedGifs();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesGetSavedGifsAnswer(qint64 msgId, const MessagesSavedGifs &result) {
    callBackCall<MessagesSavedGifs >(msgId, result);
    Q_EMIT messagesGetSavedGifsAnswer(msgId, result);
}

void TelegramCore::onMessagesGetSavedGifsError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const MessagesSavedGifs &result = MessagesSavedGifs();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesSavedGifs >(msgId, result, error);
    Q_EMIT messagesGetSavedGifsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesSaveGif(const InputDocument &id, bool unsave, Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesSaveGif(id, unsave);
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesSaveGifAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT messagesSaveGifAnswer(msgId, result);
}

void TelegramCore::onMessagesSaveGifError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT messagesSaveGifError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesGetInlineBotResults(const InputUser &bot, const QString &query, const QString &offset, Callback<MessagesBotResults > callBack) {
    if(!mApi) {
        const MessagesBotResults &result = MessagesBotResults();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesGetInlineBotResults(bot, query, offset);
    if(msgId)
        callBackPush<MessagesBotResults >(msgId, callBack);
    else {
        const MessagesBotResults &result = MessagesBotResults();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesGetInlineBotResultsAnswer(qint64 msgId, const MessagesBotResults &result) {
    callBackCall<MessagesBotResults >(msgId, result);
    Q_EMIT messagesGetInlineBotResultsAnswer(msgId, result);
}

void TelegramCore::onMessagesGetInlineBotResultsError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const MessagesBotResults &result = MessagesBotResults();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesBotResults >(msgId, result, error);
    Q_EMIT messagesGetInlineBotResultsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesSetInlineBotResults(bool gallery, bool privateValue, qint64 query_id, const QList<InputBotInlineResult> &results, qint32 cache_time, const QString &next_offset, Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesSetInlineBotResults(gallery, privateValue, query_id, results, cache_time, next_offset);
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesSetInlineBotResultsAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT messagesSetInlineBotResultsAnswer(msgId, result);
}

void TelegramCore::onMessagesSetInlineBotResultsError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT messagesSetInlineBotResultsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesSendInlineBotResult(bool broadcast, const InputPeer &peer, qint32 reply_to_msg_id, qint64 random_id, qint64 query_id, const QString &id, Callback<UpdatesType > callBack) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesSendInlineBotResult(broadcast, peer, reply_to_msg_id, random_id, query_id, id);
    if(msgId)
        callBackPush<UpdatesType >(msgId, callBack);
    else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesSendInlineBotResultAnswer(qint64 msgId, const UpdatesType &result) {
    callBackCall<UpdatesType >(msgId, result);
    Q_EMIT messagesSendInlineBotResultAnswer(msgId, result);
}

void TelegramCore::onMessagesSendInlineBotResultError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    Q_EMIT messagesSendInlineBotResultError(msgId, errorCode, errorText);
}


qint64 TelegramCore::photosUpdateProfilePhoto(const InputPhoto &id, const InputPhotoCrop &crop, Callback<UserProfilePhoto > callBack) {
    if(!mApi) {
        const UserProfilePhoto &result = UserProfilePhoto();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->photosUpdateProfilePhoto(id, crop);
    if(msgId)
        callBackPush<UserProfilePhoto >(msgId, callBack);
    else {
        const UserProfilePhoto &result = UserProfilePhoto();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onPhotosUpdateProfilePhotoAnswer(qint64 msgId, const UserProfilePhoto &result) {
    callBackCall<UserProfilePhoto >(msgId, result);
    Q_EMIT photosUpdateProfilePhotoAnswer(msgId, result);
}

void TelegramCore::onPhotosUpdateProfilePhotoError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const UserProfilePhoto &result = UserProfilePhoto();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UserProfilePhoto >(msgId, result, error);
    Q_EMIT photosUpdateProfilePhotoError(msgId, errorCode, errorText);
}

qint64 TelegramCore::photosUploadProfilePhoto(const InputFile &file, const QString &caption, const InputGeoPoint &geo_point, const InputPhotoCrop &crop, Callback<PhotosPhoto > callBack) {
    if(!mApi) {
        const PhotosPhoto &result = PhotosPhoto();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->photosUploadProfilePhoto(file, caption, geo_point, crop);
    if(msgId)
        callBackPush<PhotosPhoto >(msgId, callBack);
    else {
        const PhotosPhoto &result = PhotosPhoto();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onPhotosUploadProfilePhotoAnswer(qint64 msgId, const PhotosPhoto &result) {
    callBackCall<PhotosPhoto >(msgId, result);
    Q_EMIT photosUploadProfilePhotoAnswer(msgId, result);
}

void TelegramCore::onPhotosUploadProfilePhotoError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const PhotosPhoto &result = PhotosPhoto();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<PhotosPhoto >(msgId, result, error);
    Q_EMIT photosUploadProfilePhotoError(msgId, errorCode, errorText);
}

qint64 TelegramCore::photosDeletePhotos(const QList<InputPhoto> &id, Callback<QList<qint64> > callBack) {
    if(!mApi) {
        const QList<qint64> &result = QList<qint64>();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->photosDeletePhotos(id);
    if(msgId)
        callBackPush<QList<qint64> >(msgId, callBack);
    else {
        const QList<qint64> &result = QList<qint64>();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onPhotosDeletePhotosAnswer(qint64 msgId, const QList<qint64> &result) {
    callBackCall<QList<qint64> >(msgId, result);
    Q_EMIT photosDeletePhotosAnswer(msgId, result);
}

void TelegramCore::onPhotosDeletePhotosError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const QList<qint64> &result = QList<qint64>();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<QList<qint64> >(msgId, result, error);
    Q_EMIT photosDeletePhotosError(msgId, errorCode, errorText);
}

qint64 TelegramCore::photosGetUserPhotos(const InputUser &user_id, qint32 offset, qint64 max_id, qint32 limit, Callback<PhotosPhotos > callBack) {
    if(!mApi) {
        const PhotosPhotos &result = PhotosPhotos();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->photosGetUserPhotos(user_id, offset, max_id, limit);
    if(msgId)
        callBackPush<PhotosPhotos >(msgId, callBack);
    else {
        const PhotosPhotos &result = PhotosPhotos();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onPhotosGetUserPhotosAnswer(qint64 msgId, const PhotosPhotos &result) {
    callBackCall<PhotosPhotos >(msgId, result);
    Q_EMIT photosGetUserPhotosAnswer(msgId, result);
}

void TelegramCore::onPhotosGetUserPhotosError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const PhotosPhotos &result = PhotosPhotos();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<PhotosPhotos >(msgId, result, error);
    Q_EMIT photosGetUserPhotosError(msgId, errorCode, errorText);
}


qint64 TelegramCore::updatesGetState(Callback<UpdatesState > callBack) {
    if(!mApi) {
        const UpdatesState &result = UpdatesState();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->updatesGetState();
    if(msgId)
        callBackPush<UpdatesState >(msgId, callBack);
    else {
        const UpdatesState &result = UpdatesState();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onUpdatesGetStateAnswer(qint64 msgId, const UpdatesState &result) {
    callBackCall<UpdatesState >(msgId, result);
    Q_EMIT updatesGetStateAnswer(msgId, result);
}

void TelegramCore::onUpdatesGetStateError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const UpdatesState &result = UpdatesState();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesState >(msgId, result, error);
    Q_EMIT updatesGetStateError(msgId, errorCode, errorText);
}

qint64 TelegramCore::updatesGetDifference(qint32 pts, qint32 date, qint32 qts, Callback<UpdatesDifference > callBack) {
    if(!mApi) {
        const UpdatesDifference &result = UpdatesDifference();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->updatesGetDifference(pts, date, qts);
    if(msgId)
        callBackPush<UpdatesDifference >(msgId, callBack);
    else {
        const UpdatesDifference &result = UpdatesDifference();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onUpdatesGetDifferenceAnswer(qint64 msgId, const UpdatesDifference &result) {
    callBackCall<UpdatesDifference >(msgId, result);
    Q_EMIT updatesGetDifferenceAnswer(msgId, result);
}

void TelegramCore::onUpdatesGetDifferenceError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const UpdatesDifference &result = UpdatesDifference();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesDifference >(msgId, result, error);
    Q_EMIT updatesGetDifferenceError(msgId, errorCode, errorText);
}

qint64 TelegramCore::updatesGetChannelDifference(const InputChannel &channel, const ChannelMessagesFilter &filter, qint32 pts, qint32 limit, Callback<UpdatesChannelDifference > callBack) {
    if(!mApi) {
        const UpdatesChannelDifference &result = UpdatesChannelDifference();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->updatesGetChannelDifference(channel, filter, pts, limit);
    if(msgId)
        callBackPush<UpdatesChannelDifference >(msgId, callBack);
    else {
        const UpdatesChannelDifference &result = UpdatesChannelDifference();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onUpdatesGetChannelDifferenceAnswer(qint64 msgId, const UpdatesChannelDifference &result) {
    callBackCall<UpdatesChannelDifference >(msgId, result);
    Q_EMIT updatesGetChannelDifferenceAnswer(msgId, result);
}

void TelegramCore::onUpdatesGetChannelDifferenceError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const UpdatesChannelDifference &result = UpdatesChannelDifference();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesChannelDifference >(msgId, result, error);
    Q_EMIT updatesGetChannelDifferenceError(msgId, errorCode, errorText);
}


qint64 TelegramCore::uploadSaveFilePart(qint64 file_id, qint32 file_part, const QByteArray &bytes, Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->uploadSaveFilePart(file_id, file_part, bytes);
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onUploadSaveFilePartAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT uploadSaveFilePartAnswer(msgId, result);
}

void TelegramCore::onUploadSaveFilePartError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT uploadSaveFilePartError(msgId, errorCode, errorText);
}

qint64 TelegramCore::uploadGetFile(const InputFileLocation &location, qint32 offset, qint32 limit, Callback<UploadFile > callBack) {
    if(!mApi) {
        const UploadFile &result = UploadFile();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->uploadGetFile(location, offset, limit);
    if(msgId)
        callBackPush<UploadFile >(msgId, callBack);
    else {
        const UploadFile &result = UploadFile();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onUploadGetFileAnswer(qint64 msgId, const UploadFile &result) {
    callBackCall<UploadFile >(msgId, result);
    Q_EMIT uploadGetFileAnswer(msgId, result);
}

void TelegramCore::onUploadGetFileError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const UploadFile &result = UploadFile();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UploadFile >(msgId, result, error);
    Q_EMIT uploadGetFileError(msgId, errorCode, errorText);
}

qint64 TelegramCore::uploadSaveBigFilePart(qint64 file_id, qint32 file_part, qint32 file_total_parts, const QByteArray &bytes, Callback<bool > callBack) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->uploadSaveBigFilePart(file_id, file_part, file_total_parts, bytes);
    if(msgId)
        callBackPush<bool >(msgId, callBack);
    else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onUploadSaveBigFilePartAnswer(qint64 msgId, bool result) {
    callBackCall<bool >(msgId, result);
    Q_EMIT uploadSaveBigFilePartAnswer(msgId, result);
}

void TelegramCore::onUploadSaveBigFilePartError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    Q_EMIT uploadSaveBigFilePartError(msgId, errorCode, errorText);
}


qint64 TelegramCore::usersGetUsers(const QList<InputUser> &id, Callback<QList<User> > callBack) {
    if(!mApi) {
        const QList<User> &result = QList<User>();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->usersGetUsers(id);
    if(msgId)
        callBackPush<QList<User> >(msgId, callBack);
    else {
        const QList<User> &result = QList<User>();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onUsersGetUsersAnswer(qint64 msgId, const QList<User> &result) {
    callBackCall<QList<User> >(msgId, result);
    Q_EMIT usersGetUsersAnswer(msgId, result);
}

void TelegramCore::onUsersGetUsersError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const QList<User> &result = QList<User>();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<QList<User> >(msgId, result, error);
    Q_EMIT usersGetUsersError(msgId, errorCode, errorText);
}

qint64 TelegramCore::usersGetFullUser(const InputUser &id, Callback<UserFull > callBack) {
    if(!mApi) {
        const UserFull &result = UserFull();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->usersGetFullUser(id);
    if(msgId)
        callBackPush<UserFull >(msgId, callBack);
    else {
        const UserFull &result = UserFull();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onUsersGetFullUserAnswer(qint64 msgId, const UserFull &result) {
    callBackCall<UserFull >(msgId, result);
    Q_EMIT usersGetFullUserAnswer(msgId, result);
}

void TelegramCore::onUsersGetFullUserError(qint64 msgId, qint32 errorCode, const QString &errorText) {
    const UserFull &result = UserFull();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UserFull >(msgId, result, error);
    Q_EMIT usersGetFullUserError(msgId, errorCode, errorText);
}


TelegramCore::~TelegramCore()
{
    QHashIterator<qint64, void*> i(mCallbacks);
    while(i.hasNext())
    {
        i.next();
        Callback<int> *ptr = reinterpret_cast<Callback<int>*>(i.value());
        delete ptr;
    }
    mCallbacks.clear();
}

